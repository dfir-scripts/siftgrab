#!/bin/bash
## todo logfile, indx deep registry, windows eventlogs, carving
#set time to UTC
export TZ='Etc/UTC'

#Read Me File
function read_me(){
echo "
https://github.com/dfir-scripts
########################################################################################
Siftgrab is an  automation script written in Bash to parse Windows forensic artifacts 
from Linux.  It is a wrapper for open source forensic tools to mount and extract
Windows artifacts.

The name siftgrab is somewhat of a misnomer and is a reference SANS 508 Gold Paper I wrote in 2018.
The original idea was to incorporate a parser that would work inside of the SANS Sift Linux distro.
Since then it has been expanded and updated to install natively on Debian based systems and as a Docker container.

I use it every day in my forensics lab and it is frequently updated.

Installation Option 1:
Install script
########################################################################################
To install all tools and dependancies, run the following commands:
  (Recommended installation is using fresh VM installation of Ubuntu or WSL Ubuntu.)

  INSTALLATION COMMANDS:
    wget https://raw.githubusercontent.com/dfir-scripts/installers/main/install-forensic-tools.sh
    sudo chmod 755 install-forensic-tools.sh
    sudo ./install-forensic-tools.sh

Installation Option 2:
Docker Install
########################################################################################
Download and install latest version
  sudo docker pull dfirscripts/siftgrab:latest
  
Run (Use -v paramerter to access mount points and output folders outside of docker)
  sudo docker run -it -v /mnt:/mnt -v /cases:/cases dfirscripts/siftgrab
  

Installation Detail:
  Directory creation:
    The following directories are created:
     /mnt/raw
     /mnt/image_mount
     /mnt/vss
     /mnt/shadow
     /mnt/bde
     /mnt/smb
     /cases
     /usr/local/src (contains directories of installed software)
     /opt/app/<symbolic link to /usr/local/src>

  Installed Tools:
    When possible, tools are installed using the Gift/Stable PPA Repository
    (https://launchpad.net/~gift/+archive/ubuntu/stable). Tools like plaso, automatically 
    install many dependant packages that are not listed below.
    ########################################################################################
    From Gift PPA:
      libscca libewf-tools libbde-tools libvshadow-tools libesedb-tools liblnk-tools
      libevtx-tools plaso-tools bulk-extractor

    From Python PIP:
      python-evtx python-registry usnparser tabulate regex iocextract oletools bits_parser pandas construct

    From Github:
      https://github.com/msuhanov/yarp
      https://github.com/msuhanov/dfir_ntfs
      https://github.com/dkovar/analyzeMFT
      https://github.com/fireeye/BitsParser
      https://github.com/dfir-scripts
      https://github.com/keydet89/Tools
      https://github.com/obsidianforensics/hindsight
      https://github.com/davidpany/WMI_Forensics
      https://github.com/volatilityfoundation/volatility3
      https://github.com/kacos2000
      https://github.com/williballenthin/INDXParse
      https://github.com/DidierStevens/DidierStevensSuite
      https://github.com/threeplanetssoftware/sqlite_miner
      https://github.com/brimorlabs/KStrike
      https://github.com/MarkBaggett/srum-dump
      https://github.com/salehmuhaysin/JumpList_Lnk_Parser
      https://github.com/wagga40/Zircolite
      https://github.com/stuxnet999/EventTranscriptParser
      https://github.com/Silv3rHorn/4n6_misc
      https://github.com/williballenthin/python-registry
      https://github.com/harelsegev/INDXRipper
      https://github.com/omerbenamram/evtx
      https://github.com/omerbenamram/mft
      https://github.com/Yamato-Security/hayabusa
      https://github.com/gokcehan/lf
      https://cert.at/de/downloads/software/software-densityscout
      https://github.com/gleeda/misc-scripts/blob/master/misc_python/jobparser.py
      https://github.com/gchq/CyberChef

    From Github (Yara Rules using get-yara-rules.sh)
      https://github.com/Neo23x0/signature-base
      https://github.com/bartblaze/Yara-rules
      https://github.com/Yara-Rules
      https://github.com/reversinglabs/reversinglabs-yara-rules
      TODO: https://github.com/dfirdetective/WinSearchAppCache

    From APT (Common)
      git curl net-tools vim fdisk fdupes sleuthkit attr dcfldd afflib-tools autopsy qemu-utils 
      lvm2 exfatprogs kpartx pigz exif dc3dd python-is-python3 pff-tools python3-lxml sqlite3 jq 
      yara gddrescue unzip p7zip-full p7zip-rar hashcat foremost testdisk chntpw graphviz ffmpeg 
      mediainfo ifuse clamav geoip-bin geoip-database geoipupdate python3-impacket libsnappy-dev
      reglookup

    From APT (Kali Only):
       gnome-terminal libewf-dev ewf-tools libbde-utils libvshadow-utils libesedb-utils xmount
       liblnk-utils libevtx-utils python3-llfuse python3-libesedb plaso

 Launching Siftgrab
########################################################################################
  To access the siftgrab menu simply type: sudo siftgrab

 dfir-scripts
********************************************************
 Mount and Extract Information From Windows Disk Images
********************************************************
**  1)  Mount a Disk or Image with ermount
        (E01, RAW, AFF, QCOW, VMDK, VHDX or Physical disk)
**  2)  Process Windows Artifacts from a Mounted Disk, Image or Collection
**  3)  Multiple System Processing of Windows Artifacts (e.g. KAPE, CyLR)
**  4)  Windows Event Log Extraction  and Sigma Scan
**  5)  Registry Extraction and Timeline (Regripper)
**  6)  Copy Windows Artifacts from Mounted Image(s)
**  7)  lf - Terminal file manager
**  8)  Read me

Select a menu option number or enter to exit. 
    Select a menu option number or enter to exit.

Menu Options Detail
########################################################################################
    1)  Mount a Disk or Image with ermount

       Mounting disks
       Basic disk mounting (ermount) can be performed using siftgrab menu selection 1) 
       or from the terminal which provides extended options.  Disk mounting should occur
	   before running the docker instance of siftgrab 
       ********************************************************
       EverReady Disk Mount
       Mount/umounts disk and disk images
       (E01, vmdk, vhd(x), vdi, raw, iso, hfs+, qcow2 and vss)

       USAGE: /usr/local/bin/ermount [-h -s -u -b -rw] -i  \
       <Image file or Disk> -m <Mount Point> -t <File System Type>

       OPTIONAL:
           -i Image file or disk source to mount
           -m Mount point (Default /mnt/image_mount)
           -t File System Type (Default NTFS)
           -h This help text
           -s ermount status
           -u umount all disks from /usr/local/bin/ermount mount points
           -b mount bitlocker encrypted volume
           -rw mount image read write

        Default mount point: /mnt/image_mount
        Minimum requirements:
        ewf-tools, afflib3, qemu-utils, libvshadow-utils, libbde-utils
        Works best with updated drivers from the gift repository
        (add-apt-repository ppa:gift/stable)
        Warning: forcefully disconnects mounted drives and Network Block Devices
        When in doubt reboot
        ********************************************************
        Additional information on ermount can be found here:

        https://dfir-scripts.medium.com/forensic-mounting-of-disk-images-using-ubuntu-20-04-fe8165fca3eb

    2)  Analyze Windows Artifacts: Mounted Disk, Image or Collection(e.g. KAPE, CyLR)

       Once Windows file atrifacts are readable from the system
        (mounted disk or artifact collection) siftgrab can then process artifacts.

        IMPORTANT NOTE: Artifacts must be located in their original path!
        (example: registry files <source_path>/Windows/System32/config)

        Menu selection #2 prompts for the following information:
               Image source directory (default /mnt/image_mount)
               Destination (default /cases).
               Choose y/n to process \$USNJRNL and \$LogFile?
               Choose y/n to process event logs greater than 500MB
               Choose y/n to backup copies of Windows Event Logs, Registry and \$MFT
        If data exists and can be parsed, output will be created
        for the following different data types:
           Creates Timelines Repairs registry hives, dumps lsa secrets and NTLM hashes
           MFT, USNJRNL, RecycleBin, Prefetch, Windows Event Logs, Chrome, Firefox,
           Brave, Jumplist, LNK, Registry, Amcache, OBJECTS.DATA, BITS, Alternate Data
           Streams, services, jobs, scheduled tasks, winactivities,Chrome, Firefox,
           IE/Edge, srudb, current.mdb, Windows Events Logs, winactivities.

        Sigma scans results are created using Hayabusa.

    3)  Analyze Windows Artifacts Collected from Multiple Systems (e.g. KAPE, CyLR)
        Recursive results using same process as selection 2
        Source path is the Directory holding unzipped collections
        Example of source data:
          /mnt/hgfs/USB/R&D_Vlan
          Each system's root path is similar to extracted Kape/CyLR collections
               /mnt/hgfs/USB/R&D_Vlan/RD_System1/C
               /mnt/hgfs/USB/R&D_Vlan/RD_System2/C
               ...

    4)  Extract Windows Eventlogs to jsonl and Sigma Scan using Hayabusa
        Extracts Windows Event Logs to jsonl, run Hayabusa and several parsers.
        Output goes to a destination named WindowsEventLogs

    5)  Analyze Windows Registry
        Run regripper on Windows registry.
        Output goes to a directory using the computer name in the system registry

    6)  Save a copy of Windows Artifacts
        Save a Gzipped copy of common Windows Artifacts from a mounted disk
 
    7)  lf - Terminal file manager
        Launch lf file system browser

    8)  Read me
        View this readme file

Results
########################################################################################

Triage Output:
By default output data goes to the /cases directory but can be sent to a network share 
Output is sorted by artifact category:
./ActivitiesCache
./Alert
./BITS
./Browser_Activity
./Deleted_Files
./LogFile
./lolbas
./LNK
./MFT
./PCA
./PowerShell
./Prefetch
./RDP
./Registry/Impacket
./Registry/Regripper/Account_Info
./Registry/Regripper/CLSID
./Registry/Regripper/File_Access
./Registry/Regripper/Program_Execution
./Registry/Regripper/Run_Keys
./Registry/Regripper/Settings
./Registry/Regripper/System_Info/Network
./Registry/Regripper/System_Info/Software
./Registry/Regripper/USERS
./Registry/Regripper/User_Searches
./Registry/yarp-registryflush.py
./SRUM
./ScheduledTasks
./Services
./Timeline
./USB
./UserAccessLog
./USNJRNL
./WindowsEventLogs
./WMI

########################################################################################

"
}
#Function to produce Red Text Color
function make_red() {
    COLOR='\033[01;31m' # bold red
    RESET='\033[00;00m' # normal white
    MESSAGE=${@:-"${RESET}Error: No message passed"}
    echo -e "${COLOR}${MESSAGE}${RESET}"
}
#Function to produce Green Text Color
function make_green() {
    COLOR='\033[0;32m' # Green
    RESET='\033[00;00m' # normal white
    MESSAGE=${@:-"${RESET}Error: No message passed"}
    echo -e "${COLOR}${MESSAGE}${RESET}"
}
# reusable interactive yes_no function
function yes_no(){
      read -p "(Y/N)?"
      [ "$(echo $REPLY | tr [:upper:] [:lower:])" == "y" ] &&  yes_no="yes";
}
##  Main dfir-scripts Display Menu Function
echo ""
function show_menu(){
    GRAY=`echo "\033[0;37m"`
    GREEN=`echo "\033[0;32m"`
    NORMAL=`echo "\033[m"`
    RED=`echo "\033[31m"`
    echo -e "${GREEN} dfir-scripts 2024_6${NORMAL}"
    echo -e "********************************************************"
    echo -e "${GRAY} Mount and Extract Information From Windows Disk Images${NORMAL}"
    echo -e "********************************************************"
    echo -e "**  1) ${GREEN} Mount a Disk or Image with ermount
        (E01, RAW, AFF, QCOW, VMDK, VHDX or Physical disk)${NORMAL}"
    echo -e "**  2)${GREEN}  Process Windows Artifacts from a Mounted Disk, Image or Collection${NORMAL}"
    echo -e "**  3)${GREEN}  Multiple System Processing of Windows Artifacts (e.g. KAPE, CyLR)${NORMAL}"
    echo -e "**  4)${GREEN}  Windows Event Log Extraction and Sigma Scan${NORMAL}"
    echo -e "**  5) ${GREEN} Registry Extraction and Timeline (Regripper)${NORMAL}"
    echo -e "**  6) ${GREEN} Copy Windows Artifacts from Mounted Image(s)${NORMAL}"
    echo -e "**  7) ${GREEN} lf - Terminal file manager${NORMAL}"
    echo -e "**  8) ${GREEN} Terminal${NORMAL}"
    echo -e "**  9) ${GREEN} Read me${NORMAL}"
    echo ""
    echo -e "Select a menu option number or ${RED}enter to exit. ${NORMAL}"
    read opt
while [ opt != '' ]
    do
    if [[ $opt = "" ]]; then
            exit;
    else
        case $opt in
        #Menu Selection: Mount disk image using /usr/local/bin/ermount
        1) clear
           #check for docker
           [ -f /.dockerenv ] && make_red "Siftgrab is running from Docker!!" && \
echo "Start Siftgrab Docker using the \"-v\" option to access the host's images and disks
" && make_green "(e.g.  sudo docker run -it -v -v /media:/media /mnt:/mnt -v /cases:/cases  siftgrab)
" && show_menu;
           /usr/local/bin/ermount -h
           read -n1 -r -p "Press any key to continue..." key
           /usr/local/bin/ermount
           show_menu;
           ;;

        #Menu Selection: Process Artifacts Collected using RegRipper and other Tools
        2) clear;
           make_green "Process Artifacts for Triage"
           set_msource_path
           set_windir
           get_computer_name
           set_dsource_path
           check_dsource_path
           create_triage_dir
           get_evtxsize
           start_time=$SECONDS
           #todo  event_transcript_parser
           repair_hives
           jumplink_parser
           lnkinfo
           rip_software
           rip_system
           rip_security
           rip_sam
           rip_ntuser_usrclass
           rip_amcache.hve
           secrets_dump
           timeline_registry
           prefetch_extract
           objects_data_extract
           jobs_extract
           recbin2tln
           browser_extract
           winservices
           kstrike_current.mdb
           bits_parser
           extract_winactivities
           extract_PCA
           get_ps_console_log
           evtx_dump_json
           run_hayabusa
           parse_evtx_jsonl
           rdp_parse
           #zircolite_evtx
           srum_dump
           analyze_mft
           dump_mft
           [ "$usn" ] && parse_usn
           consolidate_timeline
           scan_for_lolbas
           #Clean-up
           make_green "Removing Duplicates..."
           echo "Please Wait..."
           fdupes -rdN $case_dir
           make_green "The Processed Artifacts are Located in $case_dir"
           du -sh $case_dir
           make_green Process Complete!
           elapsed=$(( SECONDS - start_time ))
           eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
           find $case_dir -empty -delete
           read -n1 -r -p "Press any key to continue..." key
           show_menu;
            ;;
        #Menu Selection: Process Artifacts Collected using RegRipper and other Tools
        3) clear;
          make_green "
Enter path containing multiple extracted Kape or Cylr collections
(DATA SOURCE/server_names/drive_letters)
          "
          set_msource_path
          echo $mount_dir
          set_dsource_path
          echo $case_dir
          recurse_source
          exit
           read -n1 -r -p "Press any key to continue..." key
           show_menu;
            ;;
        #Menu Selection: Extract Windows Event Log to jsonl
        4) clear;
           make_green "Analyze Windows Event Logs (evtx_dump, Hayabusa and custom scripts)"
           make_green "Default Source Directory: Windows/System32/winevt/Logs"
           set_msource_path
		   set_windir
		   get_computer_name
           set_dsource_path
		   check_dsource_path
           create_triage_dir
           make_red "Exporting Windows Event Logs to jsonl"
           evtx_dump_json
           run_hayabusa
           parse_evtx_jsonl
           rdp_parse
           du -sh $case_dir
           make_green Process Complete!
           elapsed=$(( SECONDS - start_time ))
           eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
           find $case_dir -empty -delete
           read -n1 -r -p "Press any key to continue..." key
           clear
           show_menu;
            ;;
        #Menu Selection: Run Regripper on a mounted volume or data source
        5) clear;
           make_green "Run Registry Analysis tools (Regripper, Yarp + RegistryFlush, Secretsdump)"
           set_msource_path
           set_windir
           get_computer_name
           set_dsource_path
           check_dsource_path
           create_triage_dir
           start_time=$SECONDS
           #todo  event_transcript_parser
           repair_hives
           rip_software
           rip_system
           rip_security
           rip_sam
           rip_ntuser_usrclass
           rip_amcache.hve
           secrets_dump
           timeline_registry
           #Clean-up
           make_green "Removing Duplicates..."
           echo "Please Wait..."
           fdupes -rdN $case_dir
           make_green "The Processed Artifacts are Located in $case_dir"
           du -sh $case_dir
           make_green Process Complete!
           elapsed=$(( SECONDS - start_time ))
           eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
           find $case_dir -empty -delete
           read -n1 -r -p "Press any key to continue..." key
           clear;
           show_menu;
            ;;
        #Menu Selection:  Acquire Data from Mounted Disks or Image Excerpts
        6) clear;
           /opt/app/dfir-scripts/shellscripts/grab-winfiles.sh
           read -n1 -r -p "Press any key to continue..." key
           clear;
           show_menu;
            ;;
        #Menu Selection:Lf File Browser
        7) clear;
           cd /cases
           lf
           clear;
           show_menu;
            ;;
        #Menu Selection:terminal
        8) clear;
           cd /cases
           bash
           show_menu;
            ;;
        #Menu Selection:dfir-scripts Readme and Tools
        9) clear;
           cd /opt/app
           read_me |less
           show_menu;
            ;;
        x)exit;
        ;;
        \n)clear;
           exit;
        ;;
        *)clear;
        make_red "Pick an option from the menu";
        show_menu;
        ;;
    esac
fi
done
}

####### DATA ACQUISITION AND PROCESSING PREFERENCES #######

# Sets Data Source or mount point
function set_msource_path(){
      echo ""
      make_red "SET DATA SOURCE"
      echo "Set Path or Enter to Accept Default:"
      read -e -p "" -i "/mnt/image_mount/" mount_dir
      [ ! -d "${mount_dir}" ] && make_red "Path does not exist.." && sleep 1 && exit
      mount_dir=$(echo $mount_dir |sed 's_.*_&\/_'|sed 's|//*|/|g')
      echo "Data Source =>" $mount_dir
}

# Set Case Destination Folder (Default = /cases)
function set_dsource_path(){
      make_red "SET CASE DESTINATION FOLDER (Default = /cases/)"
      echo "Set Path or Enter to Accept:"
      read -e -p "" -i "/cases" case_dir
      [ ! -d "${case_dir}" ] && make_red "Path does not exist.." && sleep 2 && show_menu
      case_dir="$case_dir/$comp_name"
      timeline_dir="$case_dir/Timeline"
}
function check_dsource_path(){
      [ -d "$case_dir" ] && echo "$case_dir already exists! overwrite?" && \
      yes_no && rm -r $case_dir/ && quit="no"
      [ -d "$case_dir" ] && [ "$quit" != "no" ] && exit
      mkdir -p $case_dir
      echo "Case Folder =>  $case_dir"
}

#Find "Windows" directory paths
function set_windir(){
      cd $mount_dir
      windir=$(find $mount_dir -maxdepth 1 -type d 2>/dev/null|egrep -m1 -i windows$)
      winsysdir=$(find $windir -maxdepth 1 -type d 2>/dev/null|egrep -m1 -i windows\/system32$)
      user_dir=$(find $mount_dir -maxdepth 1 -type d 2>/dev/null|egrep -m1 -i users$)
      regdir=$(find $winsysdir -maxdepth 1 -type d 2>/dev/null|egrep -m1 -i \/config$)
      [ "$regdir" != "" ] && echo  "Registry Directory =>" $regdir || regdir=$mount_dir
      evtxdir=$(find $winsysdir -type f -iname "*evtx" -printf '%h\n' -quit)
      len_evtxdir=$(echo $evtxdir | wc -c)
      [ "$regdir" == "$mount_dir" ] && user_dir=$mount_dir
      sam_hive=$(find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i -m1 "\/sam$")
      system_hive=$(find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i -m1 "\/system$")
      security_hive=$(find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i -m1 "\/security$")
      software_hive=$(find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i -m1 "\/software$")
      amcache_hive=$(find $windir/[a,A]*/[P,p][R,r]* -maxdepth 1 -type f 2>/dev/null|egrep -m1 -i \/amcache.hve$)
      registry_hives=("$software_hive" "$sam_hive" "$system_hive" "$security_hive" "$amcache_hive")
      [ "$windir" != "" ] && echo "Windows Directory => $windir"
      [ "$winsysdir" != "" ] && echo "Windows System32 Directory => $winsysdir"     
      [ "$regdir" != "" ] && echo  "Registry Directory =>" $regdir || regdir=$mount_dir
      [ "$evtxdir" == "2" ] && echo  "Windows Eventlog Directory =>" $evtxdir
      [ "$len_evtxdir" == 2 ] &&  evtxdir=$mount_dir
      [ "$user_dir" != "" ] && echo "Users Dir =>" $user_dir
}

#Get Computer Name using Regripper's "comp_name" plugin
function get_computer_name(){
   [ "$comp_name" == "" ] && [ "$system_hive" ] && \
   comp_name=$(reglookup -H -p /ControlSet001/Control/ComputerName/ComputerName/ComputerName "$system_hive" |awk -F',' '{print $3}')
   [ "$comp_name" == "" ] && comp_name=$(date +'%Y-%m-%d-%H%M')
   echo "SessionName:" $comp_name
   #cleanup and create a new new temp file to hold regripper output
   rm /tmp/$comp_name.* 2>/dev/null
   tempfile=$(mktemp /tmp/$comp_name.XXXXXXXX)
}

#Create Output Directory
function create_triage_dir(){
triage_dirs=("ActivitiesCache" "ADS" "Alert" "Amcache" "BITS" "Browser_Activity" "Deleted_Files" "EventTranscript" "LNK" "LogFile" \
"lolbas" "MFT" "PCA"  "PowerShell" "Prefetch" "RDP" "Registry/Regripper/Account_Info" "Registry/Regripper/File_Access" \
"Registry/Regripper/Program_Execution" "Registry/Regripper/Run_Keys" "Registry/Regripper/CLSID" "Registry/Regripper/Settings" \
"Registry/Regripper/System_Info/Network" "Registry/Regripper/System_Info/Software" "USB" "Registry/Regripper/USERS" \
"Registry/Regripper/User_Searches" "Registry/yarp-registryflush.py" "Registry/Impacket" "ScheduledTasks" "Services" "SRUM" "Summary" \
"Timeline" "USNJRNL" "UserAccessLog" "WindowsEventLogs" "WMI")
    for dir_names in "${triage_dirs[@]}";
    do
      mkdir -p $case_dir/$dir_names
    done
}

##############ACQUISITION FUNCTIONS############################

#Check Windows Event Logs Size
function get_evtxsize(){
    cd $mount_dir
    du -sh $evtxdir && \
    $evtxdir -size +500M -printf "%s bytes\t%p\n" 2>/dev/null|sort| grep . && \
    make_red "There are some event logs larger than 500M... This could take a long time. Do you want to extract them?" && \
    yes_no || evtx_max="-size -500M"
}


######### PROCESSING FUNCTIONS##############

function recurse_source(){
    recurse_mount_dir=$mount_dir
    recurse_case_dir=$case_dir
    recurse_timeline_dir=$timeline_dir
    recurse_triage_dir=$case_dir
    #source /opt/venv/bin/activate
    find $mount_dir -maxdepth 2 -type d 2>/dev/null |grep -Ei \/[A-Z]{1}$ | sed 's|${mount_dir}||'|awk -F'/' '{print "/"$(NF-1)"/"$NF}' | \
    while read d;
    do
      start_time=$SECONDS
      mount_dir=$mount_dir$d/
      set_windir
      get_computer_name
      timeline_dir="$case_dir/Timeline"
      create_triage_dir
      repair_hives
      jumplink_parser
      lnkinfo
      rip_software
      rip_system
      rip_security
      rip_sam
      rip_ntuser_usrclass
      rip_amcache.hve
      secrets_dump
      timeline_registry
      prefetch_extract
      objects_data_extract
      jobs_extract
      recbin2tln
      browser_extract
      winservices
      kstrike_current.mdb
      bits_parser
      extract_winactivities
      extract_PCA
      evtx_dump_json
      run_hayabusa
      parse_evtx_jsonl
      rdp_parse
      #zircolite_evtx
      srum_dump
      analyze_mft
      dump_mft
      consolidate_timeline
      scan_for_lolbas
      Clean-up
      make_green "Removing Duplicates..."
      echo "Please Wait..."
      fdupes -rdN $case_dir
      make_green "The Processed Artifacts are Located in $case_dir"
      du -sh $case_dir
      make_green Process Complete!
      elapsed=$(( SECONDS - start_time ))
      echo "Completed at:"
      date 2>/dev/null >> $case_dir/Triage-Timestamp.txt
      eval "echo Elapsed processing time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp.txt
      find $case_dir -empty -delete
      comp_name=""
      mount_dir=$recurse_mount_dir
      triage_dir=$recurse_triage_dir
      case_dir=$recurse_case_dir
      timeline_dir=$recurse_timeline_dir
    done
}

#Read registry hives and merge transaction logs for dirty hives
function repair_hives(){
  mkdir -p $case_dir/Registry/yarp-registryflush.py/$comp_name
  cd $case_dir/Registry/yarp-registryflush.py/$comp_name
  find $regdir -maxdepth 1 -type f 2>/dev/null | \
  grep -Eio "software$"\|"system$"\|"sam$"\|"security$" | \
  while read d;
  do
    make_green "Yarp + registryFlush -> reading $d"
    /opt/venv/bin/python /opt/app/Silv3rhorn/registryFlush.py -f  \
    $regdir/$d -o $case_dir/Registry/yarp-registryflush.py/$comp_name
  done
  find "$user_dir/" -maxdepth 2 ! -type l|\
  grep -i ntuser.dat$ |while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      mkdir -p $case_dir/Registry/yarp-registryflush.py/$comp_name/"$user_name"
      cd $user_dir/"$user_name"
      make_green "Yarp + registryFlush -> reading "$user_name"/NTUSER.DAT"
      /opt/venv/bin/python /opt/app/Silv3rhorn/registryFlush.py -f \
      "$ntuser_path" -o $case_dir/Registry/yarp-registryflush.py/$comp_name/"$user_name"
      sleep .5
    done
  find $case_dir/Registry/yarp-registryflush.py/$comp_name -type f |while read d; do a=$(echo "$d"| awk -F'/' '{print $(NF)}'); rip.pl -a -r $d >> $case_dir/Registry/Regripper/"$a"-MERGED;done
}

function jumplink_parser(){
    cd $mount_dir
    lnk_exists=$(find $user_dir/*/AppData/Roaming/Microsoft/Windows/Recent/ maxdepth 1 -type f 2>/dev/null |grep -i -m1 lnk$)
    if [ -f "$lnk_exists" ]; then
      make_green "Running JLParse.py extracting LNKS and Jumplists to json"
      /opt/venv/bin/python /opt/app/JumpList_Lnk_Parser/JLParser.py -p -a \
      /opt/app/EricZimmerman/AppIDs.csv -d $user_dir -o $case_dir/LNK/JumpList_Lnk_Parser-$comp_name.json
      sleep 1
      /opt/app/dfir-scripts/WinEventLogs/jq/JLParser-stats.sh \
      $case_dir/LNK/JumpList_Lnk_Parser-$comp_name.json >> $case_dir/Summary/JL-stats-$comp_name.txt 
    fi
}

function lnkinfo(){
    cd $mount_dir
    lnk_exists=$(find $user_dir/*/AppData/Roaming/Microsoft/Windows/Recent/ maxdepth 1 -type f 2>/dev/null |grep -i -m1 lnk$)
    if [ -f "$lnk_exists" ]; then
      make_green "extracting lnk files (lnkinfo)"
      find $user_dir/ -type f|grep lnk$ | \
      while read d;
      do
        echo $d && \
        /usr/bin/lnkinfo -v "$d"  >> $case_dir/LNK/lnkinfo-$comp_name.txt
      done
    fi
}

#Run select RegRipper plugins on Software Registry
function rip_software(){
  
  if [ -f "$software_hive" ]; then
    cd $case_dir
    make_green "Running select RegRipper plugins on the Software Registry Hives"
    sleep 1
    rip.pl -r $software_hive -p winver \
    >> $case_dir/Windows_Version_Info-$comp_name.txt;
    rip.pl -r $software_hive -p lastloggedon 2>/dev/null >> $case_dir/Registry/Regripper/Account_Info/Last-Logged-On-$comp_name.txt;
    rip.pl -r $software_hive -p networklist 2>/dev/null  >> $case_dir/Registry/Regripper/System_Info/Network/Network-List-$comp_name.txt;
    rip.pl -r $software_hive -p networksetup2 2>/dev/null >> $case_dir/Registry/Regripper/System_Info/Network/Network-Setup-$comp_name.txt;
    rip.pl -r $software_hive -p profilelist 2>/dev/null >> $case_dir/Registry/Regripper/Account_Info/User-Profiles-$comp_name.txt;
    rip.pl -r $software_hive -p pslogging 2>/dev/null >> $case_dir/PowerShell/Powershell-logging-policy-$comp_name.txt;
    rip.pl -r $software_hive -p execpolicy 2>/dev/null >> $case_dir/PowerShell/Powershell-execution-policy-$comp_name.txt;
    rip.pl -r $software_hive -p powershellcore 2>/dev/null >> $case_dir/PowerShell/Powershell-powershellcore-$comp_name.txt;    
    rip.pl -r $software_hive -p clsid_tln 2>/dev/null |  \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1",task_root,"$3","$4","$5}' >> $case_dir/Registry/Regripper/CLSID/Clsid-Registered-Classes-$comp_name.txt;
    rip.pl -r $software_hive -p cmd_shell 2>/dev/null >> $case_dir/Registry/Regripper/Settings/Cmd_Shell-$comp_name.txt;
    rip.pl -r $software_hive -p portdev 2>/dev/null >> $case_dir/USB/USB_Device_List-$comp_name.txt;
    rip.pl -r $software_hive -p runonceex | grep -va "^$" >> $case_dir/Registry/Regripper/Run_Keys/Run-Once-$comp_name.txt;
    rip.pl -r $software_hive -p appcertdlls | grep -va "^$" >> $case_dir/Registry/Regripper/Settings/Appcertsdlls-$comp_name.txt;
    rip.pl -r $software_hive -p appinitdlls | grep -va "^$" >> $case_dir/Registry/Regripper/Settings/AppInitdlls-$comp_name.txt;
    rip.pl -r $software_hive -p dcom | grep -va "^$" >> $case_dir/Registry/Regripper/Settings/ports-$comp_name.txt;
    rip.pl -r $software_hive -p psscript | grep -va "^$" >> $case_dir/Registry/Regripper/Settings/Powershell-Script-$comp_name.txt;
    rip.pl -r $software_hive -p msis | grep -va "^$" >> $case_dir/Registry/Regripper/System_Info/Software/Msiexec-Installs-$comp_name.txt;
    rip.pl -r $software_hive -p uninstall | grep -va "^$" >> $case_dir/Registry/Regripper/System_Info/Software/Add-Remove-Programs-$comp_name.txt;
    rip.pl -r $software_hive -p netsh | grep -va "^$" >> $case_dir/Registry/Regripper/Settings/Netsh-$comp_name.txt;
    rip.pl -r $software_hive -p srum | grep -va "^$" >> $case_dir/SRUM/Regripper-srum-$comp_name.txt;
    rip.pl -r $software_hive -p run | grep -va "^$" >> $case_dir/Registry/Regripper/Run_Keys/Autorun-SOFTWARE-$comp_name.txt;
    rip.pl -r $software_hive -p defender >> $case_dir/Registry/Regripper/Settings/Defender-$comp_name.txt;
    rip.pl -r $software_hive -p disablemru >> $case_dir/Registry/Regripper/Settings/DisableMRU-$comp_name.txt;
    rip.pl -r $software_hive -f software 2>/dev/null >> $case_dir/Registry/Regripper/SOFTWARE-$comp_name.txt;
    rip.pl -r $software_hive -p scriptleturl >> $case_dir/Registry/Regripper/CLSID/Scriptleturl-$comp_name.txt
    rip.pl -r $software_hive -p exefile >> $case_dir/Registry/Regripper/Settings/Exefile-$comp_name.txt
    rip.pl -r $software_hive -p tasks_tln | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1",task_root,"$3","$4","$5}' >> $case_dir/ScheduledTasks/Regripper-Task-Keys-$comp_name.txt
    rip.pl -r $software_hive -p taskcache_tln | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1",taskcache,"$3","$4","$5}' >> $case_dir/ScheduledTasks/Regripper-Task-Keys-$comp_name.txt
    rip.pl -r $software_hive -p wbem >> $case_dir/WMI/Regripper-wbem-$comp_name.txt
    rip.pl -r $software_hive -p uacbypass >> $case_dir/Registry/Regripper/Settings/UacBypass-$comp_name.txt
    rip.pl -aT -r $software_hive 2>/dev/null|sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
  fi
}

#Run select RegRipper plugins on the System Registry
function rip_system(){
  if [ -f "$system_hive" ]; then
    cd $case_dir
    make_green "Running select RegRipper plugins on the System Registry Hive(s)"
    sleep 1
    rip.pl -r $system_hive -p compname 2>/dev/null \
    >> $case_dir/Registry/Regripper/System_Info/Computer-Name-$comp_name.txt;
    rip.pl -r $system_hive -p nic2 2>/dev/null \
    >> $case_dir/Registry/Regripper/System_Info/Network/NIC2-$comp_name.txt;
    rip.pl -r $system_hive -p networksetup2 2>/dev/null |\
    >> $case_dir/Registry/Regripper/System_Info/Network/Networksetup2-$comp_name.txt;
    rip.pl -r $system_hive -p shares 2>/dev/null| \
    >> $case_dir/Registry/Regripper/System_Info/Network/Shares-$comp_name.txt;
    rip.pl -r $system_hive -p routes \
    >> $case_dir/Registry/Regripper/System_Info/Network/Routes-$comp_name.txt;
    rip.pl -r $system_hive -p ips \
    >> $case_dir/Registry/Regripper/System_Info/Network/IPAddress-$comp_name.txt;
    rip.pl -r $system_hive -p shimcache \
    >> $case_dir/Registry/Regripper/Program_Execution/Shimcache-$comp_name.txt;
    rip.pl -r $system_hive -p usb \
    >> $case_dir/USB/USB-$comp_name.txt;
    rip.pl -r $system_hive -p wpdbusenum \
    >> $case_dir/USB/Wpdbusenum-$comp_name.txt;
    rip.pl -r $system_hive -p usbstor \
    >> $case_dir/USB/USBStor-$comp_name.txt;
    rip.pl -r $system_hive -p usbdevices \
    >> $case_dir/USB//USBStor-$comp_name.txt;
    rip.pl -r $system_hive -p backuprestore \
    >> $case_dir/Registry/Regripper/Settings/Not-In-VSS-$comp_name.txt;
    rip.pl -r $system_hive -p timezone \
    >> $case_dir/Registry/Regripper/Settings/Timezone-$comp_name.txt;
    rip.pl -r $system_hive -p profiler \
    >> $case_dir/Registry/Regripper/Account_Info/Environmental-Variables-$comp_name.txt
    rip.pl -r $system_hive -p ntds \
    >> $case_dir/Registry/Regripper/Settings/ntds-$comp_name.txt;
    rip.pl -r $system_hive -p printmon \
    >> $case_dir/Registry/Regripper/Settings/Printmon-$comp_name.txt;
    rip.pl -r $system_hive -p termserv \
    >> $case_dir/Registry/Regripper/Settings/Termserv-$comp_name.txt;
    rip.pl -r $system_hive -p devclass \
    >> $case_dir/USB//USBdesc-$comp_name.txt;
    rip.pl -r $system_hive -p lsa \
    >> $case_dir/Registry/Regripper/Settings/Lsa-$comp_name.txt;
    rip.pl -r $system_hive -p disableremotescm \
    >> $case_dir/Registry/Regripper/Settings/disableremote-sc.exe-$comp_name.txt;
    rip.pl -r $system_hive -p rdpport \
    >> $case_dir/Registry/Regripper/Settings/RDP-Port-$comp_name.txt;
    rip.pl -r $system_hive -p remoteaccess \
    >> $case_dir/Registry/Regripper/Settings/Remote-Access-Lockout-$comp_name.txt;
    rip.pl -aT -r $d 2>/dev/null |sed "s/|||/|${comp_name}|${user_name}|/"\
    >> $tempfile
    rip.pl -r $system_hive -f system 2>/dev/null \
    >> $case_dir/Registry/Regripper/SYSTEM-$comp_name.txt;
  fi
}

#Run select RegRipper plugins on the Security Registry
function rip_security(){
  if [ -f "$security_hive" ]; then
    cd $case_dir
    make_green "Running select RegRipper plugins on the Security Registry Hive(s)"
    sleep 1
    rip.pl -a -r $security_hive \
    >> $case_dir/Registry/Regripper/Settings/Audit-Policy-$comp_name.txt;
    rip.pl -aT -r $security_hive | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
    rip.pl -r $security_hive -f security >> $case_dir/Registry/Regripper/SECURITY-$comp_name.txt;
  fi
}

#Run RegRipper on SAM Registry hive
function rip_sam(){
  if [ -f "$sam_hive" ]; then
    cd $mount_dir
    make_green "Searching for SAM (Regripper)"
    sleep 1
    find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i "\/sam$"|\
    while read d;
    do
      rip.pl -r "$d" -a >> $case_dir/Registry/Regripper/SAM-$comp_name.txt;
    done
    find $regdir -maxdepth 1 -type f 2>/dev/null | grep -i "\/sam$" |\
    while read d;
    do
      rip.pl -aT -r $d |sed "s/|SAM||/|SAM|${comp_name}|/" >> $tempfile
    done
  fi
}

#Run Select Regripper plugins on NTUSER.DAT and USRCLASS.DAT
function rip_ntuser_usrclass(){
  if [ -d "$user_dir" ]; then
    make_green "Searching for NTUSER.DAT KEYS (Regripper)"
    sleep 1
    cd $user_dir/
    find "$user_dir/" -maxdepth 2 ! -type l|\
    grep -i ntuser.dat$ |while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      usrclass_file=$(find $user_dir/"$user_name"/[aA]*[aA]/[lL]*[lL]/[mM][iI]*[tT]/[wW]*[sS] -maxdepth 3 -type f 2>/dev/null| \
      grep -i -m1 "\/usrclass.dat$")
      rip.pl -f ntuser -r "$ntuser_path" 2>/dev/null \
      >> "$case_dir/Registry/Regripper/USERS/NTUSER-$comp_name-$user_name.txt"
      rip.pl -aT -r "$ntuser_path" 2>/dev/null |\
      sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
      rip.pl -f usrclass -r "$usrclass_file" 2>/dev/null \
      >> "$case_dir/Registry/Regripper/USERS/USRCLASS-$comp_name-$user_name.txt"
      rip.pl -aT -r "$usrclass_file" 2>/dev/null |\
      sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Program_Execution/UserAssist-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p userassist \
      >> "$case_dir/Registry/Regripper/Program_Execution/UserAssist-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Program_Execution/Muicache-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p muicache \
      >> "$case_dir/Registry/Regripper/Program_Execution/Muicache-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p muicache 2>/dev/null\
      >> "$case_dir/Registry/Regripper/Program_Execution/Muicache-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Appx-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p appx |grep -va "^$"\
      >> "$case_dir/Registry/Regripper/Run_Keys/Appx-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p appx 2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Appx-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Settings/Exefile-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p exefile  2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Settings/Exefile-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Settings/UacBypass-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p uacbypass  2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Settings/UacBypass-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/CLSID/Clsid-Registered-Classes-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p clsid |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/CLSID/Clsid-Registered-Classes-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p clsid 2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/CLSID/Clsid-Registered-Classes-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/CLSID/Clsid-Registered-Classes-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p scriptleturl 2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/CLSID/Scriptleturl-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/RecentDocuments-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p recentdocs \
      >> "$case_dir/Registry/Regripper/File_Access/RecentDocuments-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/ShellBags-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p shellbags 2>/dev/null\
      >> "$case_dir/Registry/Regripper/File_Access/ShellBags-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Cmd_Proc-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p cmdproc |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Cmd_Proc-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Run-MRU-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p runmru |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Run-MRU-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/photos-$comp_name.txt"
      rip.pl -r "$usrclass_file" -p photos 2>/dev/null |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/File_Access/photos-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/opened-saved-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p comdlg32 |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/File_Access/opened-saved-$comp_name.txt"
      echo "######  "$user_name"  ######" |\
      >> "$case_dir/Registry/Regripper/User_Searches/Wordwheel-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p wordwheelquery |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/User_Searches/Wordwheel-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedpaths-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p typedpaths |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedpaths-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedurls-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p typedurls |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedurls-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedurlstime-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p typedurlstime |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/User_Searches/Typedurlstime-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Run_Keys/User_Run-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p run |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Run_Keys/User_Run-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Settings/Compatibility_Flags-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p appcompatflags |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Settings/Compatibility_Flags-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Account_Info/Logons-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p logonstats |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Account_Info/Logons-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Program_Execution/Jumplist-Reg-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p jumplistdata |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Program_Execution/Jumplist-Reg-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/Mount-Points-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p mp2 |grep -va "^$" \
      >>  "$case_dir/Registry/Regripper/File_Access/Mount-Points-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/File_Access/Office-cache-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p oisc |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/File_Access/Office-cache-$comp_name.txt"
      echo "######  "$user_name"  ######" |\
      >> "$case_dir/Registry/Regripper/Account_Info/Environmental-Variables-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p profiler |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Account_Info/Environmental-Variables-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Load-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p load |grep -va "^$" \
      >> "$case_dir/Registry/Regripper/Run_Keys/Load-$comp_name.txt"
      echo "######  "$user_name"  ######" \
      >> $case_dir/Registry/Regripper/System_Info/Software/Software-Installed-$comp_name.txt;
      rip.pl -r "$ntuser_path" -p listsoft |grep -va "^$" \
      >> $case_dir/Registry/Regripper/System_Info/Software/Software-Installed-$comp_name.txt;
      echo "######  "$user_name"  ######"  \
      >> "$case_dir/Registry/Regripper/File_Access/Regripper-RLO-Check-$comp_name.txt"
      rip.pl -r "$ntuser_path" -p rlo |grep -va "^$" \
      >> "$case_dir/Alert/Regripper-RLO-Check-$comp_name.txt"
    done
  fi
}

#Run RegRipper on AmCache.hve and stack hashes
function rip_amcache.hve(){
  if [ -f "$amcache_hive" ]; then
    make_green "Extracting Any RecentFileCache/AmCache (amcache.py)"
    rip.pl -aT -r "$amcache_hive" 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" \
    >> $tempfile
    rip.pl -aT -r "$amcache_hive" 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}' >> "$case_dir/Amcache/Amcache-$comp_name.csv"
  fi
  if [ -f "$case_dir/Amcache/Amcache-$comp_name.csv" ]; then
    cat "$case_dir/Amcache/Amcache-$comp_name.csv" |sed -r 's/(.*)\(/\1- /'|sed -r 's/(.*)\)/\1/'| \
    awk -F' - ' -v a=$comp_name '{print $3","$2","a}' >> "$case_dir/Summary/Amcache-Hashes-$comp_name.csv"
  fi
}

# Dump offline hashes and LSA secrets
function secrets_dump(){
  if [ -f "$sam_hive" ]; then
    make_green "Dumping Hashes and LSA Secrets (secrets_dump.py)"
    /root/.local/pipx/venvs/impacket/bin/secretsdump.py -sam $sam_hive -system $system_hive -security $security_hive local >> $case_dir/Registry/Impacket/secrets_dump-$comp_name.txt
  fi
}

# Timeline registry
function timeline_registry(){
  if [ -f "$sam_hive" ]; then
    [ "$opt" == "4" ] || Timeline="Timeline"
    make_green "Timelining Registry (regtime.pl)"
    for hive in "${registry_hives[@]}";
    do
      regtime.pl -r $hive 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" \
      >> $timeline_dir/Registry-timeline-$comp_name.TLN
    done
    cd $user_dir/
    find "$user_dir/" -maxdepth 2 ! -type l|grep -i ntuser.dat$ |\
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      [ "$user_name" ] && regtime.pl -r "${ntuser_path}" 2>/dev/null | \
      sed "s/|||/|${comp_name}|${user_name}|/" \
      >> $timeline_dir/Registry-timeline-$comp_name.TLN
    done
    cat $timeline_dir/Registry-timeline-$comp_name.TLN | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}'| \
    sort -rn >> $timeline_dir/Registry-timeline-$comp_name.csv
  fi
}

#Timeline Windows Services
function winservices(){
  if [ -f "$system_hive" ]; then
    cd $mount_dir
    make_green "Searching for Windows Services (winservices.py)"
    sleep 1
    /opt/venv/bin/python /opt/app/dfir-scripts/python/winservices.py $system_hive |sort -r \
    >> $case_dir/Services/winservices.py-$comp_name.csv;
    if [ -f "$case_dir/Services/winservices.py-$comp_name.csv" ]; then
      cat "$case_dir/Services/winservices.py-$comp_name.csv" |grep -P ^[0-9]{4} | while read f;
        do
          timestamp=$(echo "$f" awk -F',' '{print $1}'| grep -Eo '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) (2[0-3]|[01][0-9]):[0-5][0-9]:[0-5][0-9]')
          tlntime=$(date -d "$timestamp"  +"%s" 2>/dev/null)
          tlninfo=$(echo "$f"| awk -F',' '{print "||[Service Last Write]: "$2";"$3";"$5";"$7";"$8}')
          echo $tlntime"|Svc|"$comp_name$tlninfo >> $tempfile
        done
    fi
  fi
}

#Timeline Prefetch and extract metadata
function prefetch_extract(){
  cd $mount_dir
  prefetch=$(find $windir/ -maxdepth 1 -type d -iname *prefetch*)
  if  [ "$prefetch" ]; then
    rm /tmp/prc.txt 2>/dev/null
    make_green "Searching for Prefetch Files (prefetchruncounts.py)"
    /opt/venv/bin/python /opt/app/dfir-scripts/python/prefetchruncounts.py "$prefetch" >> $case_dir/Prefetch/prefetchruncounts-$comp_name.csv
    /opt/venv/bin/python /opt/app/dfir-scripts/python/prefetchruncounts.py "$prefetch" -t >> /tmp/prc.txt
    sleep 1
    [ -f "/tmp/prc.txt" ] && cat /tmp/prc.txt |while read d;
    do
      timestamp=$(echo $d| awk -F',' '{print $1}'| \
      grep -Eo '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) (2[0-3]|[01][0-9]):[0-5][0-9]:[0-5][0-9]')
      [ "$timestamp" != "" ] && tlntime=$(date -d "$timestamp"  +"%s" 2>/dev/null)
      [ "$tlntime" != "" ] && tlninfo=$(echo $d| \
      awk -F',' '{print "[Program Execution] PF_File:"$3" Executable:"$4" Run Count:"$2" Volumes"$5}')
      [ "$timestamp" != "" ] && echo $tlntime"|prefetch|"$comp_name"||"$tlninfo  >> $tempfile
    done
    rm /tmp/prc.txt
  fi
}

#Parse OBJECTS.DATA file
objects_data_extract(){
  objects_data=$(find $winsysdir/wbem/Repository/ 2>/dev/null| grep -i -m1 '\/objects.data$')
  if [ -f "$objects_data" ]; then
    cd $mount_dir
    make_green "Parsing OBJECTS.DATA file (PyWMIPersistenceFinder.py, CCM-RecentApps.py)"
    sleep 1
    find $winsysdir/wbem -maxdepth 2 -type f 2>/dev/null  | \
    grep -i '\/objects.data$'|sed 's|^\./||'|\
    while read d;
    do
      python2 /usr/local/bin/CCM_RUA_Finder.py -i "$d" -o $case_dir/WMI/CCM-RUA_Finder-$comp_name.csv
      python2 /usr/local/bin/PyWMIPersistenceFinder.py "$d" >> $case_dir/WMI/pyWMI-Persistence-Finder-$comp_name.csv
    done
  fi
}

 #Run Jobparse.py
function jobs_extract(){
  tasks_job=$(find $windir -maxdepth 3 -type f | grep -i '\/tasks$'| grep -i -m1 \.job$)
  if [ -f "$tasks_job" ]; then
    cd $mount_dir
    task_dir=
    make_green "Searching for SCHEDULED TASKS (jobsparser.py)"
    sleep 1
    find $windir -maxdepth 2 -type d 2>/dev/null  | \
    grep -i '\/tasks$'|sed 's|^\./||'|\
    while read d;
    do
      echo "######## $d ########" >> $case_dir/ScheduledTasks/jobsparser.py-$comp_name.txt
      python2 /usr/local/bin/jobparser.py -d "$d" >> $case_dir/ScheduledTasks/jobsparser.py-$comp_name.txt
    done
  fi
}

#Timeline recycle.bin metadata
function recbin2tln(){
  if  [ "$(ls -A /$mount_dir/\$Recycle.Bin 2>/dev/null)" ]; then
    make_green "Parsing \$Recycle.Bin (recbin2tln)"
    /opt/app/dfir-scripts/shellscripts/recbin2tln.sh . -c |sed "s/cle,,/cle,$comp_name|/" >> $case_dir/Deleted_Files/Recycled-$comp_name.csv
    /opt/app/dfir-scripts/shellscripts/recbin2tln.sh . |sed "s/cle||/cle|$comp_name|/" >> $tempfile
  fi
}

function browser_extract(){
   mkdir $case_dir/Browser_Activity/$comp_name
   /opt/app/dfir-scripts/shellscripts/browser_extract.sh /$mount_dir/ $case_dir/Browser_Activity/$comp_name

   # Copy Files to Timeline Temp File
   find $case_dir/Browser_Activity/$comp_name -type f |grep -iE chrome\|brave\|firefox  |\
   while read d;
   do
     cat "$d" |while read line;
     do
       timestamp=$(echo $line| awk -F',' '{print $1}' | \
       grep -Eo '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) (2[0-3]|[01][0-9]):[0-5][0-9]:[0-5][0-9]')
       [ "$timestamp" != "" ] && tlntime=$(date -d "$timestamp"  +"%s" 2>/dev/null)
       [ "$tlntime" != "" ] && tlninfo=$(echo "$f"| awk -F',' '{print "|"$2"|"$3"|"$4"|"$5}')
       tlninfo=$(echo "$line"| awk -F',' '{print "|"$2"|"$3"|"$4"|"$5}')
       echo $tlntime$tlninfo |grep -v "||||" >> $tempfile
     done
   done
}

function srum_dump(){
  sru_file=$(find $winsysdir/[S,s][R,r][U,u] -maxdepth 2 -type f -iname "srudb.dat" 2>/dev/null )
  if [ -f "$sru_file" ]; then
    make_green "Extracting $sru_file file (srum_dump2.py)
    Standby...  This might take a while"
    /opt/venv/bin/python /opt/app/srum-dump/srum_dump2.py --SRUM_INFILE "$sru_file" \
    --XLSX_OUTFILE $case_dir/SRUM/srum_dump-$comp_name.xlsx -r $regdir/SOFTWARE \
    -q -t /opt/app/srum-dump/SRUM_TEMPLATE2.xlsx
  fi
  if [ -f "$case_dir/SRUM/srum_dump-$comp_name.xlsx" ]; then
    cd "$case_dir/SRUM/"
    ssconvert -S "srum_dump-$comp_name.xlsx" srum_dump-$comp_name.csv 2>/dev/null
   fi
}

function kstrike_current.mdb(){
  current_mdb=$(find $winsysdir/[L,l]*[S,s]/[S,s][U,u][M,m] -type f -iname "Current.mdb" 2>/dev/null)
  if [ -f "$current_mdb" ]; then
    cd $mount_dir
    make_green "Parsing UserAccessLog (Current.mdb) with KStrike.py"
    /opt/venv/bin/python /opt/app/KStrike/KStrike.py "$current_mdb" \
    >> $case_dir/UserAccessLog/Kstrike-$comp_name.txt
  fi
}

#Run Bits_Parser.py and process Microsoft-Windows-Bits-Client\%4Operational.evtx
function bits_parser(){
  if [ -d "$mount_dir/ProgramData/Microsoft/Network/Downloader/" ]; then
    make_green "Searching and extracting qmgr.db (BitsParser.py)"
    /opt/venv/bin/python /opt/app/BitsParser/BitsParser.py -i \
    $mount_dir/ProgramData/Microsoft/Network/Downloader/ --carvedb --carveall 2>/dev/null \
    >> $case_dir/BITS/BitsParser.py-$comp_name.csv
  fi
}

#copy powershell console log
get_ps_console_log(){
    console_log=$(find $user_dir/*/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt 2>/dev/null)
    if [ -f "$console_log" ]; then
      make_green "Searching for PowerShell Console Log"
      cd $user_dir/
      find "$user_dir/" -maxdepth 2 ! -type l|grep -i ntuser.dat$ |\
      while read ntuser_path;
      do
        user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
        cat "$user_dir/$user_name/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt" 2>/dev/null >> $case_dir/PowerShell/$comp_name-$user_name-ConsoleHost_history.txt
       done
    fi
}

#Parse Windows History File
extract_winactivities(){
    Winactivities_file=$(find $user_dir/*/AppData/Local/C*m/ -type f 2>/dev/null |grep -i -m 1 ActivitiesCache.db$)
    if [ -f "$Winactivities_file" ]; then
      make_green "Searching for ActivitiesCache.db"
      cd $user_dir/
      find "$user_dir/" -maxdepth 2 ! -type l|grep -i ntuser.dat$ |\
      while read ntuser_path;
      do
        user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
        find "$user_dir/$user_name/AppData/Local/ConnectedDevicesPlatform" -maxdepth 5 -type f 2>/dev/null | \
        grep -i "ActivitiesCache.db$"| sed 's|^\./||'|\
        while read d;
        do
          sqlite3 "$d" ".read /opt/app/kacos2000/WindowsTimeline/WindowsTimeline.sql" 2>/dev/null >> $case_dir/ActivitiesCache/WindowsTimeline.sql-$user_name-$comp_name.csv
       done
    done
    find $case_dir/ActivitiesCache/ -type f 2>/dev/null |grep WindowsTimeline.sql | \
    while read f;
    do
      profile_name=$(echo "$f"|awk -F'Timeline.sql-' '{print $NF}')
      echo -e "******  $profile_name  ******\n Count File"  >> $case_dir/Summary/ActivitiesCache-stats-$comp_name.txt
       cat "$f" 2>/dev/null| \
       awk -F'|' '{print $3}'|grep  exe|awk -F'\' '{print $NF}'|sort |uniq -c|sort -rn \
       >> $case_dir/Summary/ActivitiesCache-stats-$comp_name.txt
       cat "$f" 2>/dev/null| \
       awk -F'|' '{print $3}'|grep -v exe|awk -F'\' '{print $NF}'|sort |uniq -c|sort -rn \
       >> $case_dir/Summary/ActivitiesCache-stats-$comp_name.txt
    done
  fi
}

extract_PCA(){
    cd $mount_dir
    if [ -f $windir/appcompat/pca/PcaAppLaunchDic.txt ]; then
      make_green "Searching for Windows 11 Program Compatibility Assistant"
      cat $windir/appcompat/pca/PcaAppLaunchDic.txt | \sed 's|\\|\\\\|g' |\
      while read d;
      do
        timestamp=$(echo "$d" | awk -F'|' '{print $2}')
        pca_path=$(echo "$d" | awk -F'|' '{print $1}')
        tln_time=$(date -d "$timestamp"  +"%s" 2>/dev/null)
        tl_time=$(echo $tln_time | awk '{$0=strftime("%Y-%m-%d %H:%M:%S",$0)}{print $0}')
        tln_line=$tln_time"|PCAdic|"$comp_name"||Program Execution:"$pca_path
        tl_line=$tl_time",PCA,"$comp_name",,Program Execution:"$pca_path
        echo $tl_line >> $case_dir/PCA/PcaAppLaunchDic.csv
        echo $tln_line  >> $tempfile
      done

      find $windir/appcompat/pca/PcaGeneralDb[0-9].txt |\
      while read d;
      do
        file_name=$(echo "$d" |awk -F'pca/' '{print $2}')
        echo  "Runtime,Run_status,Exe_path,Description,Software_vendor,File_version,ProgramId,Exitcode" \
        >> $case_dir/PCA/$file_name
        cat "$d"| tr -d '\000' | sed 's/|/,/g' \
        >> $case_dir/PCA/$file_name

        cat "$d" | sed 's|\\|\\\\|g' 2>/dev/null|\
        while read f;
        do
          timestamp=$(echo "$f" | awk -F'|' '{print $1}')
          pca_path=$(echo "$f" | awk -F'|' '{print $3}')
          tln_time=$(date -d "$timestamp"  +"%s" 2>/dev/null)
          tln_line=$tln_time"|PCAdb|"$comp_name"||Program Execution:"$pca_path
          echo $tln_line  >> $tempfile
        done
      done
    fi
}

# Extract WindowsEvent Logs to jsonl
function evtx_dump_json(){
    if [ "$evtxdir" ]; then
      cd $mount_dir
      make_green "Dumping Windows Event Logs to jsonl (evtx_dump)"
      sleep 1
      mkdir -p "$case_dir/WindowsEventLogs/evtx_dump"
      find $evtxdir -type f 2>/dev/null -size +70k $evtx_max -name '*.evtx' | \
      while read d;
      do
        evtx_file=$(basename "$d")
	    echo "Dumping $evtx_file to jsonl"
        evtx_dump "$d" --validate-checksums -o jsonl -f "$case_dir/WindowsEventLogs/evtx_dump/$evtx_file-$comp_name.jsonl"
      done
    fi
}

function run_hayabusa(){
  if [ "$evtxdir" ]; then
    cd $evtxdir
    make_green "Scanning for Sigma Alerts in EVTX files (Hayabusa)"
    mkdir -p "$case_dir/WindowsEventLogs/Hayabusa"
    cd /opt/app/Hayabusa
    hayabusa json-timeline -N --no-wizard -d $evtxdir -L -o  $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl
    sleep .5
  fi
  if [ -f $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl ]; then
   #Summary of Hayabusa Sigma Scan
   cat $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level != "info" )| "\(.Level),\(.Computer),\(.RuleTitle),\(.EventID),\(.Channel)"'|sort |uniq -c|sort -rn|sed 's/ "/,/g'|sed 's/"$//g' | \
   tee $case_dir/Alert/Hayabusa-Count-$comp_name.txt && sed -i '1i Count,Level,Computer,RuleTitle,EventID,Channel' $case_dir/Alert/Hayabusa-Count-$comp_name.txt
   # Critical, High and Medium Alerts from Hayabusa
   cat $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "crit" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//' | \
   tee $case_dir/Alert/Hayabusa-AlertsDetail-$comp_name.txt

   cat $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "high" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//'| \
   tee $case_dir/Alert/Hayabusa-AlertsDetail-$comp_name.txt

   cat $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "med" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//'| \
   tee $case_dir/Alert/Hayabusa-AlertsDetail-$comp_name.txt

   [ -f "tee $case_dir/Alert/Hayabusa-AlertsDetail-$comp_name.txt" ] && sed -i '1i Timestamp,EventID,Level,Computer,RuleTitle,Channel' tee $case_dir/Alert/Hayabusa-AlertsDetail-$comp_name.txt

   cat $case_dir/WindowsEventLogs/Hayabusa/Hayabusa-$comp_name.jsonl | \
   jq 'select(.Level != "info")|",\(.Timestamp |.[:10]),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' -r|sort |uniq -c|sort -rn|sed 's/ ,/,/g' | \
   tee $case_dir/Alert/Hayabusa-Alerts-byDate-$comp_name.txt
   [ -f "$case_dir/Alert/Hayabusa-Alerts-byDate-$comp_name.txt" ] && sed -i '1i Count,Date,EventID,Level,Computer,RuleTitle,Channel' $case_dir/Alert/Hayabusa-Alerts-byDate-$comp_name.txt
 fi
}

function parse_evtx_jsonl(){
    # Extract Powershell Logs
    find $case_dir/WindowsEventLogs/evtx_dump/ -type f 2>/dev/null | \
    grep Microsoft-Windows-PowerShell%4Operational.evtx.jsonl | \
    while read d;
    do
      cat "$d" |jq -j '.Event|select(.EventData.ScriptBlockText !=null)|.System.Computer,.System.TimeCreated."#attributes".SystemTime,.EventData.Path,.System.Security."#attributes".UserID,.EventData.ScriptBlockText,.System.Channel' >> $case_dir/PowerShell/PowerShellScriptBlocks-$comp_name.txt
    done

    find $case_dir/WindowsEventLogs/evtx_dump/ -type f 2>/dev/null | \
    grep Windows.PowerShell.evtx.jsonl| \
    while read d;
    do
      cat "$d" 2>/dev/null | \
      jq  '.Event|select(.EventData.Data."#text"!=null)|.System.Computer,.System.TimeCreated."#attributes".SystemTime,.EventData.Data,.System.Channel' \
      >> $case_dir/PowerShell/PowerShell-HostApplication-$comp_name.txt
    done

    # Get IPv4 Addresses in EVTX files
    if  [ "$(ls -A $case_dir/WindowsEventLogs/evtx_dump/ 2>/dev/null)" ]; then
      make_green "Grepping for IP v4 Addresses in EVTX files"
      echo "IP_ADDRESS,LOCATION,EVENT_LOG">>$case_dir/Summary/IPv4-Addresses-in-evtx-$comp_name.csv
      find $case_dir/WindowsEventLogs/evtx_dump/ -type f | \
      while read d;
      do
        evtx_log=$(basename "$d")
        grep -Eoa "\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b" """$d"""| \
        sort -u | grep -Ev ^0\|0\.0\.0\|^127\|^224\|^239 2>/dev/null |while read line;
        do
          a=$(geoiplookup $line 2>/dev/null|awk -F',' '{print $2}')
          [ "$a" == '' ] && a='NON_INTERNET'
          echo "$line","$a","$evtx_log", >> $case_dir/Summary/IPv4-Addresses-in-evtx-$comp_name.csv
        done
      done
    fi

    # Get Summary from Security.evtx
    find $case_dir/WindowsEventLogs/evtx_dump/ -type f 2>/dev/null | \
    grep -i \/Security.evtx.jsonl| \
    while read d;
    do
      echo "SECURITY.EVTX EVENT COUNT" >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt
      /opt/app/dfir-scripts/WinEventLogs/jq/security.evtx.count.sh "$d" \
      >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt
      echo "*********************************************************
      ">> $case_dir/Summary/Security.evtx-stats-$comp_name.txt

      echo "SECURITY.EVTX LOGIN TYPES" >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt
      /opt/app/dfir-scripts/WinEventLogs/jq/logintypescount.sh "$d" \
      >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt
      echo "*********************************************************
      ">> $case_dir/Summary/Security.evtx-stats-$comp_name.txt

      echo "SECURITY.EVTX NEW PROCESSES" >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt
      /opt/app/dfir-scripts/WinEventLogs/jq/newprocesscount.sh "$d" \
      >> $case_dir/Summary/Security.evtx-stats-$comp_name.txt

      echo "SECURITY.EVTX FAILED LOGINS" >> $case_dir/Summary/failed-logins-$comp_name.txt
      /opt/app/dfir-scripts/WinEventLogs/jq/failed_logins.sh  "$d" \
      >> $case_dir/Summary/failed-logins-$comp_name.txt

      echo "SECURITY.EVTX EXPLICIT LOGINS EID4648" \
      >> $case_dir/Summary/explicit-logins-$comp_name.txt
      /opt/app/dfir-scripts/WinEventLogs/jq/explicit_logins.sh  "$d" \
      >> $case_dir/Summary/explicit-logins-$comp_name.txt
    done

    # Create CSV of Task Scheduler from Evtx and create a summary
    task_sched="$case_dir/WindowsEventLogs/evtx_dump/Microsoft-Windows-TaskScheduler%4Operational.evtx.jsonl"
    if [ -f "${task_sched}" ]; then
      /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_jsonl_tasks.py ${task_sched} >> $case_dir/ScheduledTasks/tasks_evtx.py-$comp_name.csv;
      /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_jsonl_tasks.py -s ${task_sched} >> $case_dir/Summary/tasks_evtx_stacked.py-$comp_name.csv;
    fi
    cat $case_dir/ScheduledTasks/evtx_tasks.py-$comp_name.csv 2>/dev/null| \
    grep -E TaskStartEvent\|TaskSuccessEvent\|TaskRegisteredEvent |\
    while read d;
    do
      tlntime=$(echo $d|awk -F',' '{print $1}'| xargs -i date -d "{}" "+%s")
      evtxinfo=$(echo $d|awk -F"," '{print $2";"$6";"$3}')
      [ "$tlntime" != "" ] && echo $tlntime"|SchTask|"$comp_name"||"$evtxinfo >> $tempfile
    done

    #Microsoft-Windows-Bits-Client\%4Operational.evtx
    bits_client="$evtxdir/Microsoft-Windows-Bits-Client%4Operational.evtx"
    # extract all Bits Events to csv and then write to TLN temp file
    if [ -f "$bits_client" ]; then
      make_green "Searching for BITS Transactions... (parse_evtx_BITS.py)"
      /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_evtx_BITS.py "$bits_client" >> $case_dir/BITS/parse_evtx_BITS.py-$comp_name.csv
      sleep 1
      cat $case_dir/BITS/parse_evtx_BITS.py-$comp_name.csv |\
      while read d;
      do
        tlntime=$(echo $d|awk -F',' '{print $1}'| xargs -i date -d "{}" "+%s" 2>/dev/null)
        evtxinfo=$(echo $d|awk -F"," '{$1=""}1')
        [ "$tlntime" != "" ] && echo $tlntime"|BITS|"$comp_name"||"$evtxinfo >> $tempfile
      done
    fi
    ## Write Summary
    if [ -f $case_dir/BITS/parse_evtx_BITS.py-$comp_name.csv ]; then
      echo "WINDOWS BITS EVENT SUMMARY

 COUNT,EVENTID,DESCRIPTION,COMPUTER,PROCESSID,USER,JOBTITLE,URL,BYTES_IN,BYTES_OUT,OWNER" >> $case_dir/Summary/BITS-stacked-$comp_name.csv
      cat $case_dir/BITS/parse_evtx_BITS.py-$comp_name.csv |grep ^[1-9] | \
      awk -F',' '{print $2","$3","$4","$5","$8","$9","$10","$14","$15","$17}' |sort |uniq -c |sort -rn >> $case_dir/Summary/BITS-stacked-$comp_name.csv
    fi
}

function rdp_parse(){
    #Find RDP Connections
    if [ "$evtxdir" != '' ]; then
      mkdir -p $case_dir/RDP
      make_green "Searching for RDP Sessions (parse_evtx_RDP.py)"
      /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_evtx_RDP.py $evtxdir \
      >> $case_dir/RDP/parse_evtx_RDP.py-$comp_name.csv;
      /opt/app/dfir-scripts/WinEventLogs/RDP_Diagram.sh -f $case_dir/RDP/parse_evtx_RDP.py-$comp_name.csv \
      -o $case_dir/Summary/RDP_Diagram.sh-$comp_name.png
      cat $case_dir/RDP/parse_evtx_RDP.py-$comp_name.csv|\
      grep -E  \,21\,\|\,23\,\|\,24\,\|\,25\,\|\,1149\,\|\,98\,\|\,131\,\|\,140\,\|\,1102\|\,1105\,\|\,1029 |\
      while read d;
        do
          timestamp=$(echo $d| awk -F',' '{print $1}'| \
          grep -Eo '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) (2[0-3]|[01][0-9]):[0-5][0-9]:[0-5][0-9]')
          [ "$timestamp" != "" ] && tlntime=$(date -d "$timestamp"  +"%s" 2>/dev/null)
          evtxinfo=$(echo $d|awk -F"," '{$1=""}1')
          [ "$timestamp" != "" ] && echo $tlntime"|RDP|"$comp_name"||"$evtxinfo >> $tempfile
        done
    fi
    if [ -f $case_dir/RDP/parse_evtx_RDP.py-$comp_name.csv ]; then
      echo "WINDOWS RDP CONNECTION SUMMARY

   COUNT,EVENTID,DESCRIPTION,COMPUTER,DOMAIN,USER,HOST/IP_ADDRESS,SESSION,DIRECTION" >> $case_dir/Summary/RDP-stacked-"$comp_name".txt
      cat $case_dir/RDP/parse_evtx_RDP.py-$comp_name.csv | grep [1-9] |awk -F',' '{print ","$5","$6","$7","$8","$9","$10","$11}' |\
      sort  |uniq -c |sort -rn >> $case_dir/Summary/RDP-stacked-"$comp_name".txt
    fi
}

## Replaced by Hayabusa
#function zircolite_evtx(){
#  if [ -d "$case_dir/WindowsEventLogs/evtx_dump/" ]; then
#    make_green "Scanning for Sigma Alerts in EVTX files (Zircolite)"
#    zpath="/opt/app/Zircolite"
#    find $case_dir/WindowsEventLogs/evtx_dump/ -type f 2>/dev/null | \
#    grep -Ei sysmon.evtx.jsonl$\|\/Security.evtx.jsonl$\|\/Application.evtx.jsonl$\|\/System.evtx.jsonl$\|PowerShell\|Defender\|DNS\|Windows-Bits\|Windows-Smb\|TaskScheduler\|firewall| \
#    while read d;
#    do
#      evtx_jsonl=$(echo "$d" |awk -F'dump/' '{print $NF}')
#      /opt/venv/bin/python $zpath/zircolite.py -j -e "$d" -r $zpath/rules/rules_windows_generic_full.json -c $zpath/config/fieldMappings.json --csv -o $case_dir/Alert/Zircolite-"$evtx_jsonl"-$comp_name.csv -l $case_dir/Alert/Zircolite-log-$comp_name.txt
#    done
#    sleep .5
#    header="COUNT,LEVEL,TITLE,DESCRIPTION"
#    result=$(cat $case_dir/Alert/*.json 2>/dev/null |jq -r '.[]|select(.title!="")|"\(.count),\(.rule_level),\(.title),\(.description)"'|grep -v null,null,null|sort -rn)
#    [ "$result" != "" ] && printf "%s\n%s"  ${header} "${result}"|column -t -s "," >> $case_dir/Summary/Zircolite-stats-"$comp_name".txt
#  fi
#}

#Extract MFT to body file and then to TLN and csv files
function analyze_mft(){
  if [ -f "$mount_dir/\$MFT" ]; then
    cd $mount_dir
    make_green "Timelining \$MFT Standby...(analyzeMFT.py)"
    [ -f "\$MFT" ] && \
    /usr/local/src/analyzeMFT/analyzeMFT.py -p -f \$MFT --bodyfull --bodyfile=$case_dir/MFT/analyzeMFT-$comp_name.body
    [ -f $case_dir/MFT/analyzeMFT-$comp_name.body ] && \
    bodyfile.pl -f $case_dir/MFT/analyzeMFT-$comp_name.body -s $comp_name | \
    sort -rn >> $timeline_dir/MFT-Timeline-$comp_name.TLN.txt && \
    cat $timeline_dir/MFT-Timeline-$comp_name.TLN.txt | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}' \
    >> $timeline_dir/MFT-Timeline-$comp_name.csv
    cat $timeline_dir/MFT-Timeline-$comp_name.TLN.txt | \
    while read d;
    do
      grep -E -i \.xls$\|\.doc\|\.ps1$\|\.hta$\|\.tmp$\|\.rar$\|\.bat$\|\.cmd$\|\.vba$\|\.vbe$\|\.vbs$\|\.zip$\|\z$\|\.arj$\|\.pub$  >> $tempfile;
    done
  fi
}

#Find Deleted Files
function dump_mft(){
    if [ -f "$mount_dir/\$MFT" ]; then
      make_green "Extracting MFT (MFT_Dump)"
      mft_dump \$MFT -o csv -f $case_dir/MFT/MFT_Dump-$comp_name.csv
      #Find Unallocated files
      make_green "Locating Unallocated files"
      cat $case_dir/MFT/MFT_Dump-$comp_name.csv| \
      awk -F',' '{if($12 =="true" && $11=="false") print substr($16,1,19)",UNALLOCATED,,,FILE Last Write: FN="substr($20,1,19)";"$22;
      else if($12 =="true" && $11=="true") print substr($16,1,19)",UNALLOCATED,,,DIRECTORY Last Write: FN="substr($20,1,19)";"$22;}'| \
      sed 's/T/ /1' |sed "s/UNALLOCATED,,,/UNALLOCATED,${comp_name},,/" >> $case_dir/Deleted_Files/MFT-UNALLOCATED-$comp_name.csv
    fi
    #find ADS
    if [ -f "$case_dir/MFT/MFT_Dump-$comp_name.csv" ]; then
      make_green "Locating Files with Alternate Data Streams (ADS)"
      cat $case_dir/MFT/MFT_Dump-$comp_name.csv| \
      awk -F',' '{if($13 =="true") print substr($16,1,19)",ADS,,,FILE Last Write: FN="substr($20,1,19)";"$22;}' \
      | sed 's/T/ /1' |sed "s/,,,/,${comp_name},,/" |grep -P ^[0-9]{4} >> $case_dir/ADS/AlternateDataStreams-$comp_name.csv
    fi
}

#Extract $USNJRNL:$J to TLN
function parse_usn(){
  if [ -f "$mount_dir/\$USNJRNL:$J" ]; then
    cd $mount_dir
    make_green "Extracting \$USNJRNL:$J (usn.py)
    Standby..."
    [ -f "\$Extend/\$UsnJrnl:\$J" ] && \
    /envs/dfir/bin/usn.py -t -s $comp_name -f "\$Extend/\$UsnJrnl:\$J"  -o $case_dir/USNJRNL/usn.py-$comp_name.TLN.txt
    cat $case_dir/USNJRNL/usn.py-$comp_name.TLN.txt | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}'\
    >> $case_dir/USNJRNL/usn.py-$comp_name.csv
    make_green "Extracting \$LogFile (ntfs_parser)
    Standby..."
    [ -f "\$LogFile" ] && \
    /envs/dfir/bin/ntfs_parser --log \$MFT \$LogFile $case_dir/LogFile/ntfs_parser-LogFile-$comp_name.txt
  fi
}

#Consolidating TLN Output and consolidating timelines
function consolidate_timeline(){
      cat $tempfile | sort -rn |uniq >> $timeline_dir/Triage-Timeline-$comp_name.TLN
      cat $tempfile |awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}'|sort -rn | uniq| grep -va ",,,," >> $timeline_dir/Triage-Timeline-$comp_name.csv
      cat $timeline_dir/Triage-Timeline-$comp_name.csv|grep -ia ",alert," >> $case_dir/Alert/RegRipperAlerts-$comp_name.csv
      if [ -f "$case_dir/ADS/AlternateDataStreams-$comp_name.csv" ]; then
        cat $case_dir/ADS/AlternateDataStreams-$comp_name.csv >> $timeline_dir/Triage-Timeline-$comp_name.csv
      fi
      if [ -f "$case_dir/Deleted_Files/MFT-UNALLOCATED-$comp_name.csv" ]; then
        cat $case_dir/Deleted_Files/MFT-UNALLOCATED-$comp_name.csv >> $timeline_dir/Triage-Timeline-$comp_name.csv
      fi
}

function scan_for_lolbas(){
  if  [ "$(ls -A $case_dir/WindowsEventLogs/evtx_dump/ 2>/dev/null)" ]; then
    make_green "Searching for executables identified as lolbas"
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p  "$case_dir/WindowsEventLogs/evtx_dump/" -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-in-evtx-$comp_name.csv
    if [  -f "$case_dir/lolbas/lolbas-in-evtx-$comp_name.csv" ] ; then
      cat $case_dir/lolbas/lolbas-in-evtx-$comp_name.csv |awk -F',' '{print ","$1","$2}'|sort |uniq -c |sort -rn |sed 's/ //g' >> $case_dir/Summary/lolbas-stats-$comp_name.csv
      sed -i "1i lolbas_file,source,message" $case_dir/lolbas/lolbas-in-evtx-$comp_name.csv
    fi
  fi

  #***** Lolbas in  Alert *****************************alert

  if  [ "$(ls -A $case_dir/Alert/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Alert/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

  #***** Lolbas in prefetch *****************************
  if  [ "$(ls -A $case_dir/Prefetch/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Prefetch/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

    #***** Lolbas in AmCache *****************************
  if  [ "$(ls -A $case_dir/Amcache/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Amcache/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

  #***** Lolbas in Program Execution *****************************
  if  [ "$(ls -A $case_dir/Registry/Regripper/Program_Execution 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Registry/Regripper/Program_Execution -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

  #***** Lolbas in Run Keys *****************************
  if  [ "$(ls -A $case_dir/Registry/Regripper/Run_Keys 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Registry/Regripper/Run_Keys -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

  #***** Lolbas in Services *****************************
  if  [ "$(ls -A $case_dir/Services/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Services/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi

  #***** Lolbas in Bits *****************************
  if  [ $( -f "$case_dir/BITS/parse_evtx_BITS.py-$comp_name.csv" 2>/dev/null) ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/BITS/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-$comp_name.csv
  fi


  #insert header
  if  [ -f "$case_dir/lolbas/lolbas-$comp_name.csv" ] ; then
    cat $case_dir/lolbas/lolbas-$comp_name.csv |awk -F',' '{print ","$1","$2}'|sort |uniq -c |sort -rn |sed 's/ //g' >> $case_dir/Summary/lolbas-stats-$comp_name.csv
    sed -i "1i lolbas_file,source,message" $case_dir/lolbas/lolbas-$comp_name.csv
  fi

    #***** Lolbas in SRUM Dump *****************************
  if [  -f "$case_dir/SRUM/srum_dump-$comp_name.xlsx" ]; then
    make_green "Searching for executables identified as lolbas in srum_dump-$comp_name.xlsx"
    cd "$case_dir/SRUM/"
    ls *csv* |\
    while read d;
    do
      /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
      $case_dir/SRUM/ -l /opt/app/keywords/lolbas.csv >> $case_dir/lolbas/lolbas-srum-$comp_name.csv
    done
    sleep .5
    if [  -f "$case_dir/lolbas/lolbas-srum-$comp_name.csv" ] ; then
      cat $case_dir/lolbas/lolbas-srum-$comp_name.csv |awk -F',' '{print ","$1","$2}'|sort |uniq -c |sort -rn |sed 's/ //g'  >> $case_dir/Summary/lolbas-stats-$comp_name.csv
      sed -i "1i lolbas_file,source,message" $case_dir/lolbas/lolbas-srum-$comp_name.csv
    fi
  fi
  if [  -f "$case_dir/Summary/lolbas-stats-$comp_name.csv" ] ; then
    sed -i "1i count,lolbas_file,source" $case_dir/Summary/lolbas-stats-$comp_name.csv
  fi

  #***** Lolbas in Windows Timeline *****************************
  find $case_dir/ActivitiesCache/ -type f 2>/dev/null |grep WindowsTimeline.sql | \
    while read f;
    do
      profile_name=$(echo "$f"|awk -F'Timeline.sql-' '{print $NF}')
      cat "$f" 2>/dev/null| awk -F'|' '{print $3}'|grep  exe|awk -F'\' '{print $NF}' >> /tmp/exe.txt
      [ -f "/tmp/exe.txt" ] && echo -e "******  $profile_name  ******\n Count File"  >> $case_dir/lolbas/lolbas-in-ActivitiesCache-$comp_name.txt
      [ -f "/tmp/exe.txt" ] &&  /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p  /tmp/exe.txt -l /opt/app/keywords/lolbas.csv | awk -F',' '{print $1}' |sort | uniq -c | sort -rn \
      >> $case_dir/lolbas/lolbas-in-ActivitiesCache-$comp_name.txt
      rm /tmp/exe.txt
    done
    [ -f "$case_dir/lolbas/lolbas-in-ActivitiesCache-$comp_name.txt" ] && sed -i "1i lolbas files in ActivitiesCache.db (https://lolbas-project.github.io/)" $case_dir/lolbas/lolbas-in-ActivitiesCache-$comp_name.txt
}

#function event_transcript_parser(){
#    cd $mount_dir
#    #make_green "EventTranscript.db..."
#    find $mount_dir/ProgramData/Microsoft/Diagnosis/EventTranscript/EventTranscript.db
#    while read d;
#    do
#    /opt/venv/bin/python /opt/app/EventTranscriptParser/EventTranscriptParser.py -f "$d" -o $case_dir/EventTranscript/EventTranscript-$comp_name.csv
#    done
#}

clear
[ $(whoami) != "root" ] && make_red "dfir-scripts Requires Root!" && exit
show_menu
exit 0
