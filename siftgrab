#!/bin/bash
#set time to UTC
export TZ='Etc/UTC'

#Function to produce Red Text Color
function make_red() {
    COLOR='\033[01;31m' # bold red
    RESET='\033[00;00m' # normal white
    MESSAGE=${@:-"${RESET}Error: No message passed"}
    echo -e "${COLOR}${MESSAGE}${RESET}"
}
#Function to produce Green Text Color
function make_green() {
    COLOR='\033[0;32m' # Green
    RESET='\033[00;00m' # normal white
    MESSAGE=${@:-"${RESET}Error: No message passed"}
    echo -e "${COLOR}${MESSAGE}${RESET}"
}
# reusable interactive yes_no function
function yes_no(){
      read -p "(Y/N)?"
      [ "$(echo $REPLY | tr [:upper:] [:lower:])" == "y" ] &&  yes_no="yes";
}
##  Main dfir-scripts Display Menu Function
echo ""
function show_menu(){
    GRAY=`echo "\033[0;37m"`
    GREEN=`echo "\033[0;32m"`
    NORMAL=`echo "\033[m"`
    RED=`echo "\033[31m"`
    echo -e "${GREEN} dfir-scripts 2025_9${NORMAL}" 
    echo -e "********************************************************"
    echo -e "${GRAY} Mount and Extract Information From Windows Disk Images${NORMAL}"
    echo -e "********************************************************"
    echo -e "**  1) ${GREEN} Mount a Disk or Image with ermount
        (E01, RAW, AFF, QCOW, VMDK, VHDX or Physical disk)${NORMAL}"
    echo -e "**  2)${GREEN}  Process Windows Artifacts Using Available Parsers${NORMAL}"
    echo -e "**  3)${GREEN}  Extract Artifacts from Multiple System Acquisitions (e.g. KAPE, CyLR)${NORMAL}"
    echo -e "**  4) ${GREEN} Make a Backup Copy of Windows Artifacts from a Mounted Image(s)${NORMAL}"
    echo -e "**  5) ${GREEN} lf - Terminal File Manager${NORMAL}"
    echo -e "**  6) ${GREEN} Terminal${NORMAL}"
    echo -e "**  7) ${GREEN} Additional Parsers and Memory Analysis${NORMAL}"
    echo -e "**  8)${GREEN}  Process Windows Artifacts Using Zimmerman Tools${NORMAL}"
    echo ""
    echo -e "Select a menu option number or ${RED}enter to exit. ${NORMAL}"
    read opt
while [ opt != '' ]
    do
    if [[ $opt = "" ]]; then
            exit;
    else
        case $opt in
        #Menu Selection: Mount disk image using /usr/local/bin/ermount
        1) clear
           #check for docker
           [ -f /.dockerenv ] && make_red "Siftgrab is running from Docker!!" && \
echo "Start Siftgrab Docker using the \"-v\" option to access the host's images and disks
" && make_green "(e.g.  sudo docker run -it -v /media:/media -v /mnt:/mnt -v /cases:/cases  dfirscripts/siftgrab)
" && show_menu;
           /usr/local/bin/ermount -h
           read -n1 -r -p "Press any key to continue..." key
           /usr/local/bin/ermount
           show_menu;
           ;;

        #Menu Selection: Process artifacts using siftgrab parser collection
        2) clear;
           make_green "Process Artifacts for Triage"
           set_msource_path
           set_windir
           get_computer_name
           set_dsource_path
           check_dsource_path
           select_parsers
           create_triage_dir
           start_time=$SECONDS
           out_format=csv
           eval "echo Started! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           [ $parse_all ] && parsers || custom_parsers
           consolidate_timeline
           #Clean-up
           make_green "Removing Duplicates..."
           echo "Please Wait..."
           rm /tmp/$comp_name* 2>/dev/null
           rm /tmp/*.dot 2>/dev/null
           fdupes -rdN $case_dir
           cp_registry_vals
           make_green "The Processed Artifacts are Located in $case_dir"
           du -sh $case_dir 2>/dev/null
           make_green Process Complete!
           elapsed=$(( SECONDS - start_time ))
           eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
           find $case_dir -empty -delete 2>/dev/null
           find $case_dir -empty -delete 2>/dev/null
           read -n1 -r -p "Press any key to continue..." key
           rm /tmp/$comp_name.* 2>/dev/null
           clear
           show_menu;
            ;;
        #Menu Selection: Extract artifact collections from multiple sources (Kape, CyLR) using siftgrab parser collection
        3)clear;
          make_green "Enter path to directory containing Kape or Cylr **VHD or VHDX** files"
          out_format=csv
          mount_dir=/mnt/image_mount/C
          set_rmsource_path
          recurse_source
          read -n1 -r -p "Press any key to continue..." key
          show_menu;
          ;;
        #Menu Selection:  Acquire Data from Mounted Disks or Image Excerpts
        4) clear;
           /opt/app/dfir-scripts/shellscripts/grab-winfiles.sh
           read -n1 -r -p "Press any key to continue..." key
           clear;
           show_menu;
            ;;
        #Menu Selection:Lf File Browser
        5) clear;
           cd /cases
           lf
           clear;
           show_menu;
            ;;
        #Menu Selection:terminal
        6) clear;
           cd /cases
           bash
           show_menu;
            ;;
        # Carving and Additional Parsers
        7) carving_submenu
            clear
            show_menu;
            ;;
#***************************************
        8) clear;
           make_green "Process Artifacts using Zimmerman Tools"
           set_msource_path
           set_windir
           get_computer_name
           set_dsource_path
           check_dsource_path
           set_zimmerman_output
           create_triage_dir
           start_time=$SECONDS
########### Zimmeran Tools Artifact Parsers #################
           z_amcacheparser
           z_appcompatcacheparser
           z_lecmd_jlecmd
           z_mftecmd
           z_rbcmd
           z_recentfilecacheparser
           z_rla
           z_sbecmd
           z_wxtcmd
           z_evtxecmd
           #z_recmd
########### End Artifact Parsers ############################
#### add and remove # to disable/enable artifact parsers ####
           make_green "The Processed Artifacts are Located in $case_dir"
           du -sh $case_dir 2>/dev/null
           make_green Process Complete!
           elapsed=$(( SECONDS - start_time ))
           eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
           eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
           fd . -t e -t d $case_dir |xargs rmdir
           read -n1 -r -p "Press any key to continue..." key
           rm /tmp/$comp_name.* 2>/dev/null
           clear
           show_menu;
            ;;
        x)exit;
        ;;
        \n)clear;
           exit;
        ;;
        *)clear;
        make_red "Pick an option from the menu";
        show_menu;
        ;;
    esac
fi
done
}

####### DATA ACQUISITION AND PROCESSING PREFERENCES #######

# Sets Data Source or mount point
function set_msource_path(){
      default_msource="/mnt/image_mount/"
      echo ""
      make_red "SET DATA SOURCE"
      echo "Set Path or Enter to Accept Default:"
      read -e -p "" -i $default_msource mount_dir
      [ ! -d "${mount_dir}" ] && make_red "Path does not exist.." && sleep 1 && clear && show_menu
      [ ! -d "${mount_dir}"/[w,W]indows ] && [ -d "${mount_dir}"/[c,C] ] && mount_dir=$(find $mount_dir[c,C] -maxdepth 0 -type d)
      mount_dir=$(echo $mount_dir |sed 's_.*_&\/_'|sed 's|//*|/|g')
      echo "Data Source =>" $mount_dir
}

function set_rmsource_path(){
      echo ""
      make_red "SET DATA SOURCE"
      echo "Set Path or Enter to Accept Default:"
      read -e -p "" rmsource_path
      [ ! -d "${rmsource_path}" ] && make_red "Path does not exist.." && sleep 1 && clear && show_menu
      rmsource_path=$(echo $rmsource_path |sed 's_.*_&\/_'|sed 's|//*|/|g')
      echo "VHD(X) Search Source Path=>" $rmsource_path
}

# Set Case Destination Folder (Default = /cases)
function set_dsource_path(){
      make_red "SET CASE DESTINATION FOLDER (Default = /cases/)"
      echo "Set Path or Enter to Accept:"
      read -e -p "" -i "/cases" case_dir
      [ ! -d "${case_dir}" ] && make_red "Path does not exist.." && sleep 2 && clear && show_menu
      case0_dir=$case_dir
      case_dir="$case_dir/$comp_name"
      timeline_dir="$case_dir/Timeline"
}
function check_dsource_path(){
      [ -d "$case_dir" ] && echo "$case_dir already exists! overwrite?" && \
      yes_no && rm -r $case_dir/ && quit="no"
      [ -d "$case_dir" ] && [ "$quit" != "no" ] && clear && show_menu
      mkdir -p $case_dir
      echo "Case Folder =>  $case_dir"
}
function set_zimmerman_output(){
      make_red "SET OUTPUT FORMAT (Default = csv)"
      echo "Set output format to csv or json"
      read -e -p "" -i "csv" out_format
      #grep -Eq csv\|json || make_red "invalid output format.." && sleep 2 && clear && show_menu
}

#Find "Windows" directory paths
function set_windir(){
      cd $mount_dir
      windir=$(fd windows$ -d 1 -t d -i $mount_dir 2>/dev/null)
      winsysdir=$(fd system32 -d 1 -t d -i $windir 2>/dev/null)
      user_dir=$(fd users$ -d 1 -t d -i $mount_dir 2>/dev/null)
      readarray -t user_names < <(fd . -d 1 -t d $user_dir 2>/dev/null | awk -F '/' '{print $(NF)}')
      regdir=$(fd config$ -d 1 -t d -i $winsysdir 2>/dev/null)
      [ "$regdir" != "" ] && echo  "Registry Directory =>" $regdir || regdir=$mount_dir
      evtxdir=$(find $winsysdir/*evt/*ogs/ -maxdepth 0 -type d 2>/dev/null)
      [ "$evtxdir" == "" ] &&  evtxdir=$(fd -t f evtx$ . |xargs dirname |sort -u | grep -m1 \/)
      len_evtxdir=$(echo $evtxdir | wc -c)
      sam_hive=$(fd SAM$ -d 1 -t f -i $regdir 2>/dev/null)
      system_hive=$(fd SYSTEM$ -d 1 -t f -i $regdir 2>/dev/null)
      security_hive=$(fd SECURITY$ -d 1 -t f -i $regdir 2>/dev/null)
      software_hive=$(fd SOFTWARE$ -d 1 -t f -i $regdir 2>/dev/null)
      amcache_hive=$(fd -t f -d 1 -i amcache.hve$ $windir/*/Programs 2>/dev/null)
      csv2XL="/opt/app/dfir-scripts/csv2XLsheet/csv2XLsheet"
      all_users=$(fd ProgramData$ -d 1 -t d -i $mount_dir 2>/dev/null)
      [ "$windir" != "" ] && echo "Windows Directory => $windir"
      [ "$winsysdir" != "" ] && echo "Windows System32 Directory => $winsysdir"     
      [ "$regdir" != "" ] && echo  "Registry Directory =>" $regdir || regdir=$mount_dir
      [ "$len_evtxdir" == 2 ] &&  evtxdir=$mount_dir
      [ "$evtxdir" != "" ] && echo  "Windows Eventlog Directory =>" $evtxdir
      [ "$user_dir" != "" ] && echo "Users Dir =>" $user_dir
      [ "$user_names" != "" ] && echo "Users Names => ${user_names[@]}"
}

#Get Computer Name using Regripper's "comp_name" plugin
function get_computer_name(){
   [ "$comp_name" == "" ] && [ "$system_hive" ] && \
   comp_name=$(reglookup -H -p /ControlSet001/Control/ComputerName/ComputerName/ComputerName "$system_hive" |awk -F',' '{print $3}')
   [ "$comp_name" == "" ] && comp_name=$(date +'%Y-%m-%d-%H%M') && echo "" && make_red "System Registry Not Found! Cannot Determine Computer Name!" && echo ""
   echo "Output Directory:" $comp_name
   #cleanup and create a new new temp file to hold regripper output
   rm /tmp/$comp_name.* 2>/dev/null
   tempfile=$(mktemp /tmp/$comp_name.XXXXXXXX)
}

#Create Output Directory
function create_triage_dir(){
make_green "Creating Output Directories" 
triage_dirs=("All_Slicers" "All_Summary" "Application_Execution/Amcache" "Application_Execution/Bam" "Application_Execution/Jumplist" \
"Application_Execution/PCA" "Application_Execution/Prefetch" "Application_Execution/SRUM" "Application_Execution/Shimcache" "Application_Execution/Registry_AutoStart" \
"Application_Execution/lolbas" "Artifact" "Persistence/BITS" "Persistence/ScheduledTasks" "Persistence/Services" "Persistence/Registry" "Browser_Activity" \
"File_System/Deleted_Files" "File_Access/LNK" "File_Access/ShellBags" "File_Access/Windows_Index" "File_Access/Registry_MRU" "File_System/AlternateDataStreams" \
"File_System/MFT" "File_System/USNJRNL" "File_System/Volatile" "Installed_Software" "Network_Info/UserAccessLog" "Registry_Settings/CLSID" "/Registry_Settings/Audit_Policy/" \
"Regripper/Software" "Regripper/System" "Regripper/Security" "Regripper/Sam" "User_Account_Info/Sam" "Scripting/PowerShell" "Scripting/WMI" "Sigma_Alerts" \
"Timeline/TLN" "Timeline/WinActivitiesCache" "USB" "User_Account_Info" "WindowsEventLogs" "WindowsEventLogs/RDP")

    for dir_names in "${triage_dirs[@]}";
    do
      mkdir -p $case_dir/$dir_names
    done
}

activate_venv() {
    source /opt/venv/bin/activate
    echo "Python virtual environment activated."
    # Start a subshell with a custom prompt
    bash --rcfile <(echo "PS1='(venv) \w\$ '")
    deactivate
    echo "Exited virtual environment."
}

function carving_submenu() {
    clear
    echo -e "${GREEN}Siftgrab Processing Sub-menu${NORMAL}"
    echo -e "********************************************************"
    echo -e "**  1) ${GREEN} Evtxtract (Carve binary files for Windows Event Logs)${NORMAL}"
    echo -e "**  2) ${GREEN} ntfs_parser(Deep parsing of MFT,USNJRNL,Logfile,INDX)${NORMAL}"
    echo -e "**  3) ${GREEN} prefetch-carve.py (Carve binary files for prefetch)${NORMAL}"
    echo -e "**  4) ${GREEN} usncarve.py (Carve binary files for \$usnjrnl entries)${NORMAL}"
    echo -e "**  5) ${GREEN} bulk_extractor(Image and DMP file artifact extraction)${NORMAL}"
    echo -e "**  6) ${GREEN} Didier Stevens Tools(oledump, pdftool many parsers and decoders)${NORMAL}"
    echo -e "**  7) ${GREEN} Volatility 3.0 (Memory image analysis)${NORMAL}"
    echo -e "**  8) ${GREEN} Memprocfs (Mount and analyze Windows memory images)${NORMAL}"
    echo -e "**  9) ${GREEN} BMC-Tools (Carve RDP Image Tiles from RDP Cache)${NORMAL}"
    echo -e "**  10)${GREEN} Yarp + Registryflush (Merge registry hives with transaction logs)${NORMAL}"
    echo -e "**  11)${GREEN} EventTranscriptParser.py (Parse Eventranscript.db)${NORMAL}"
    echo ""
    echo -e "Select a submenu option number or ${RED}enter to go back. ${NORMAL}"
    read subopt
    while [ subopt != '' ]
    do
        if [[ $subopt = "" ]]; then
            clear
            show_menu;
        else
            case $subopt in
                1) clear
                   make_green "Evtxtract (Carve Windows Eventlogs)"
                   cd /cases
                   /opt/venv/bin/evtxtract -h
                   echo -e  "\n \n"
                   activate_venv
                   clear
                   carving_submenu;
                   ;;
                2) clear
                   make_green "ntfs_parser (MFT,USNJRNL,INDX,$LOGFILE)"
                   cd /cases
                   /opt/venv/bin/ntfs_parser -h
                   echo -e  "\n \n"
                   activate_venv
                   clear
                   carving_submenu;
                   ;;
                3) clear
                   make_green "Prefetch-carve"
                   cd /cases
                   /opt/venv/bin/prefetch-carve.py -h
                   echo -e  "\n \n"
                   activate_venv
                   clear
                   carving_submenu;
                   ;;
                4) clear
                   make_green "usncarve"
                   cd /cases
                   /opt/venv/bin/usncarve.py -h
                   echo -e  "\n \n"
                   activate_venv
                   clear
                   carving_submenu;
                   ;;
                5) clear
                   make_green "bulk_extractor(Carve data for artifacts)"
                   cd /cases
                   bulk_extractor -h |head -n 3
                   echo -e  "\n \n"
                   bash
                   clear
                   carving_submenu;
                   ;;
                6) clear
                   make_green "Didier Stevens Suite(Many tools for artifact extraction)"
                   cd /opt/app/DidierStevensSuite/
                   echo "https://blog.didierstevens.com/didier-stevens-suite/
I bundled most of my software in a ZIP file and GitHub repository. Some software that requires installation (Ariad) or triggers too much anti-virus programs on VirusTotal was not included.

I update this ZIP file and repository each time I release a new version or a new program (excluding beta versions).

Last update: 2024/07/13

DidierStevensSuite.zip (http)
MD5: 88403A361A65E034AF14D58B23375FF9
SHA256: 557D9A03D5BECE1EFDA0E1080DFA5804FDA6D3C7A91A874AF9AE81D8FC3ABCB0"
                   echo -e  "\n \n"
                   activate_venv
                   cd /cases
                   carving_submenu;
                   ;;
                7) clear
                   make_green "Volatility 3"
                   cd /opt/app/volatility3
                   head -n 20 /opt/app/volatility3/README.md 
                   echo -e  "\n \n"
                   activate_venv
                   carving_submenu;
                   ;;
                8) clear
                   make_green "Memprocfs"
                   cd /opt/app/MemProcFS
                   echo " MemProcFS v5.11.4 COMMAND LINE REFERENCE:                                   
 MemProcFS may be used in stand-alone mode with support for memory dump files, 
 local memory via winpmem driver or together with PCILeech DMA devices.        
 -----                                                                         
 MemProcFS (c) 2018-2023 Ulf Frisk                                             
 License: GNU Affero General Public License v3.0                               
 Contact information: pcileech@frizk.net                                       
 MemProcFS:    https://github.com/ufrisk/MemProcFS                             
 LeechCore:    https://github.com/ufrisk/LeechCore                             
 PCILeech:     https://github.com/ufrisk/pcileech                              
 -----                                                                         
 The recommended way to use MemProcFS is to specify a memory acquisition device
 in the -device option. Options -f and -z equals -device.                      
 Example 1: MemProcFS.exe -f c:\temp\memdump-win10x64.raw                    
 Example 2: MemProcFS.exe -device c:\temp\memdump-win10x64.dmp -forensic 1   
 Example 3: MemProcFS.exe -device FPGA                                         
 Example 4: MemProcFS.exe -device PMEM://c:\temp\winpmem_x64.sys             
 -----"
                   echo -e  "\n \n"
                   activate_venv
                   carving_submenu;
                   ;;
                9) clear
                   make_green "BMC-Tools"
                   echo -e  "\n"
                   cd /opt/app/BMC-Tools/
                   python /opt/app/BMC-Tools/bmc-tools.py -h
                   echo -e "\nCache files location: %LOCALAPPDATA%\Microsoft\Terminal Server Client\Cache Folder\ [*.bmc, Cache*.bin]\n"
                   activate_venv
                   carving_submenu;
                   ;;
                10) clear
                   make_green "Yarp + Registryflush (Merge transaction logs to registry hives)"
                   cd /opt/venv/bin/
                   /opt/venv/bin/python registryFlush.py -h
                   echo -e  "\nsee also: yarp-carver, yarp-mount, yarp-print, yarp-timeline\n \n"
                   activate_venv
                   carving_submenu;
                   ;;
                11) clear
                   make_green "EventTranscriptParser"
                   cd  /opt/app/EventTranscriptParser
                   /opt/venv/bin/python /opt/app/EventTranscriptParser/EventTranscriptParser.py -h
                   echo -e  "./ProgramData/Microsoft/Diagnosis/EventTranscript/EventTranscript.db\n \n"
                   activate_venv
                   carving_submenu;
                   ;;
                x) clear  
                   show_menu;
                   ;;
                *) clear;
                   make_red "Pick an option from the submenu";
                   carving_submenu;
                   ;;
            esac
        fi
    done
}

##############ACQUISITION FUNCTIONS############################

function select_parsers(){
      echo ""
      echo "Enter as comma separated values
      "
      echo "Available Parsers
mft,usnjrnl,registry,regmerge,lnks,evtx,amcache,prefetch,shimcache,shellbags,ntlm_hash,recbin,srum,browser,winindex,services,current.mdb,bits,winactivities,pca,bam
"
make_red "SELECT PARSERS TO RUN"
echo "Enter to select all parsers"
      read -e -p "" -i "" parsers
      [ "$parsers" == "" ] && parse_all="yes"
      cust_mft=$(echo $parsers|grep -i mft)
      cust_usn=$(echo $parsers|grep -i usnjrnl)
      cust_reg=$(echo $parsers|grep -i registry)
      cust_sb=$(echo $parsers|grep -i shellbags)
      cust_regf=$(echo $parsers|grep -i regmerge)
      cust_lnk=$(echo $parsers|grep -i lnks)
      cust_shim=$(echo $parsers|grep -i shimcache)
      cust_bamdam=$(echo $parsers|grep -i bam)
      cust_usrc=$(echo $parsers|grep -i usrclass)
      cust_amc=$(echo $parsers|grep -i amcache)
      cust_pf=$(echo $parsers|grep -i prefetch)
      cust_hash=$(echo $parsers|grep -i ntlm_hash)
      cust_job=$(echo $parsers|grep -i jobs)
      cust_rbin=$(echo $parsers|grep -i recbin)
      cust_srum=$(echo $parsers|grep -i srum)
      cust_brow=$(echo $parsers|grep -i browser)
      cust_wini=$(echo $parsers|grep -i winindex)
      cust_svcs=$(echo $parsers|grep -i services)
      cust_cmdb=$(echo $parsers|grep -i current.mdb)
      cust_bits=$(echo $parsers|grep -i bits)
      cust_winact=$(echo $parsers|grep -i winactivities)
      cust_pca=$(echo $parsers|grep -i pca)
      cust_evtx=$(echo $parsers|grep -i evtx)
}

function custom_parsers(){
###########Artifact Parsers ##################################
           [ $cust_regf ] && z_rla
           [ $cust_lnk ] && parse_lnks
           [ $cust_shim ] && shim_cache
           [ $cust_reg ] && rip_software
           [ $cust_reg ] && rip_system
           [ $cust_reg ] && rip_security
           [ $cust_reg ] && rip_sam
           [ $cust_reg ] && rip_ntuser
           [ $cust_reg ] && rip_usrclass
           [ $cust_reg ] && rip_ntuser_tln
           [ $cust_reg ] && winservices
           [ $cust_sb ] && shellbags
           [ $cust_bamdam ] && bam_dam
           [ $cust_amc ] && extract_amcache.hve
           [ $cust_hash ] && secrets_dump
           [ $cust_pf ] && prefetch_extract
           [ $cust_job ] && jobs_extract
           [ $cust_rbin ] && rec_bin
           [ $cust_brow ] && browser_extract
           [ $cust_wini ] && parse_windows_index
           [ $cust_mft ] && analyze_mft
           [ $cust_mft ] && z_mftecmd
           [ $cust_usn ] && parse_usn
           [ $cust_log ] && parse_log_file
           [ $cust_svcs ] && winservices
           [ $cust_cmdb ] && kstrike_current.mdb
           [ $cust_bits ] && bits_parser
           [ $cust_winact ] && extract_winactivities
           [ $cust_pca ] && extract_PCA
           [ $cust_evtx ] && get_ps_console_log
           [ $cust_evtx ] && evtx_dump_json
           [ $cust_evtx ] && run_hayabusa
           [ $cust_evtx ] && parse_evtx_jsonl
           [ $cust_evtx ] && rdp_parse
           #[ $cust_evtx ] && zircolite_evtx
           [ $cust_evtx ] && evtx_hussar
           [ $cust_srum ] && srum_dump
}

function mount_vhd(){
      # Retry ermount -u up to 5 times with increasing sleep
      #local vhd_file="$1"
      retries=5
      sleep_time=1
      for ((i=1; i<=retries; i++)); do
          ermount -u
          mount_status=$(sudo ermount -s | grep 'Active')
          if [ -z "$mount_status" ]; then
              echo "Unmount successful"
              break
          elif [ "$i" == "5" ]; then
              make_red "Unmount failed!!"
              exit
          fi
          echo "Active mount found, retrying ($i/$retries)..."
          sleep $sleep_time
          ((sleep_time++))
      done
      sleep 2
      case_dir=$case0_dir
      ermount -i /"$d" -t ntfs -m /mnt/image_mount -o 32256
      if [ ! -d "/mnt/image_mount/C" ]; then
        make_red "Mount Failed $d !!"
      fi
}

function rprocess(){
    if [ -d "/mnt/image_mount/C" ]; then
      start_time=$SECONDS
      set_windir
      comp_name=""
      get_computer_name  
      case_dir="$case_dir/$comp_name"
      timeline_dir="$case_dir/Timeline"
      create_triage_dir
      eval "echo Started! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
      #******************
      [ $parse_all ] && parsers || custom_parsers
      consolidate_timeline
      #Clean-up
      make_green "Removing Duplicates..."
      echo "Please Wait..."
      rm /tmp/$comp_name* 2>/dev/null
      rm /tmp/*.dot 2>/dev/null
      fdupes -rdN $case_dir
      cp_registry_vals
      make_green "The Processed Artifacts are Located in $case_dir"
      du -sh $case_dir 2>/dev/null
      make_green $comp_name Complete!
      elapsed=$(( SECONDS - start_time ))
      eval "echo Completed! "$(date) >> $case_dir/Triage-Timestamp-$comp_name.txt
      eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" |tee -a $case_dir/Triage-Timestamp-$comp_name.txt
      find $case_dir -empty -delete 2>/dev/null
      find $case_dir -empty -delete 2>/dev/null
      rm /tmp/$comp_name.* 2>/dev/null
      ((counter++))
      cd $case_dir
    else
      mount_err=$(basename "$d") 
      echo "Mount Failed $d !!" | tee $case_dir/"$mount_err.txt"
    fi
}
######### PROCESSING FUNCTIONS##############
function recurse_source() {
    set_dsource_path
    select_parsers
    counter=0
    vhd_files=$(find "$rmsource_path" -type f -iname "*.vhd" -o -iname "*.vhdx")
    if [ -n "$vhd_files" ]; then
        for d in $vhd_files; do
            mount_vhd "$d"
            if [ -d "/mnt/image_mount/C" ]; then
              rprocess
            fi
        done
        # Wait for all background processes to complete
        wait
    fi
    make_green "Recursive Extraction Complete!"
}

function rprocess() {
      if [ $(echo $mount_dir |grep \/C$) ];then
        start_time=$SECONDS
        set_windir
        comp_name=""
        get_computer_name  
        case_dir="$case_dir/$comp_name"
        timeline_dir="$case_dir/Timeline"
        create_triage_dir
        
        eval "echo Started! $(date)" >> "$case_dir/Triage-Timestamp-$comp_name.txt"
        
        #******************
        [ "$parse_all" ] && parsers || custom_parsers
        consolidate_timeline
        
        #Clean-up
        make_green "Removing Duplicates..."
        echo "Please Wait..."
        rm /tmp/"$comp_name"* 2>/dev/null
        rm /tmp/*.dot 2>/dev/null
        fdupes -rdN "$case_dir"
        cp_registry_vals
        
        make_green "The Processed Artifacts are Located in $case_dir"
        du -sh "$case_dir" 2>/dev/null
        make_green "$comp_name Complete!"
        
        elapsed=$(( SECONDS - start_time ))
        eval "echo Completed! $(date)" >> "$case_dir/Triage-Timestamp-$comp_name.txt"
        eval "echo Elapsed time: $(date -ud "@$elapsed" +' %H hrs %M mins %S secs')" | tee -a "$case_dir/Triage-Timestamp-$comp_name.txt"
        
        find "$case_dir" -empty -delete 2>/dev/null
        find "$case_dir" -empty -delete 2>/dev/null
        rm /tmp/"$comp_name".* 2>/dev/null
        
        ((counter++))
        cd "$case_dir"
    else
        mount_err=$(basename "$vhd_file")
        echo "Mount Failed $vhd_file !!" | tee "$case_dir/$mount_err.txt"
    fi
}

function parsers(){
###########Artifact Parsers ##################################
#### add and remove # to disable/enable artifact parsers #####
           z_rla
           parse_lnks
           shim_cache
           rip_software
           rip_system
           rip_security
           rip_sam
           rip_ntuser
           rip_usrclass
           rip_ntuser_tln
           shellbags
           bam_dam
           extract_amcache.hve
           secrets_dump
           prefetch_extract
           rec_bin
           browser_extract
           parse_windows_index
           analyze_mft
           dump_mft
           z_mftecmd
           parse_usn
           winservices
           extract_PCA
           kstrike_current.mdb
           bits_parser
           extract_winactivities
           get_ps_console_log
           evtx_dump_json
           #z_evtxecmd
           run_hayabusa
           parse_evtx_jsonl
           rdp_parse
           #zircolite_evtx
           evtx_hussar
           srum_dump
           scan_for_lolbas
########### End Artifact Parsers ############################
}

function cp_artifacts(){
  make_green "Creating a local copy of registry, evtx logs and \$MFT
Standby..."
  
  mkdir -p $case_dir/Artifact/Windows/System32/config
  mkdir -p $case_dir/Artifact/Windows/System32/config/RegBack
  mkdir -p $case_dir/Artifact/Windows/System32/winevt/Logs
  cd $mount_dir
  [ "$(ls $mount_dir/\$MFT 2>/dev/null)" ] && cp $mount_dir/\$MFT $case_dir/Artifact/ 2>/dev/null
  [ "$(ls -A $regdir 2>/dev/null)" ] && cp -Lr $regdir $case_dir/Artifact/Windows/System32/config/ 2>/dev/null
  [ "$(ls -A $evtxdir 2>/dev/null)" ] && cp -L $evtxdir/*.evtx $case_dir/Artifact/Windows/System32/winevt/Logs 2>/dev/null
  find $user_dir/*/ -maxdepth 1 -type f 2>/dev/null| grep -iE NTUSER.dat$\|.log | while read d;
  do
    user_name=$(basename "$user_path")
    mkdir -p $case_dir/Artifact/Users/$user_name 2>/dev/null
    cp -L "$d" $case_dir/Artifact/Users/$user_name/ 2>/dev/null
  done
  find $windir/[I,i][N,n][F,f] -type f -iname "setupapi*log"|\
  while read d;
  do
    cp -L "$d" $case_dir/USB/setupapi.dev.log-$comp_name.txt 2>/dev/null;
  done
}

#appcompatcache
function shim_cache(){
  if [ -f "$system_hive" ]; then
    cd $regdir
    rip.pl -r $system_hive -p shimcache >> $case_dir/Application_Execution/Shimcache/RegR-AppCompatCache-$comp_name.txt
    dotnet /opt/zimmermantools/net9/AppCompatCacheParser.dll --csvf shimcache_$comp_name.csv -f $system_hive --$out_format $case_dir/Application_Execution/Shimcache
  fi
}

function parse_lnks(){
    cd $mount_dir
    lnk_exists=$(find $user_dir/*/AppData -type f 2>/dev/null |grep -i -m1 lnk$)
    if [ -f "$lnk_exists" ]; then
      make_green "Running lnk2j to extract LNKS to jsonl"
      /opt/venv/bin/python /opt/venv/bin/lnk2j.py -i $user_dir -f jsonl |tee -a  $case_dir/File_Access/LNK/lnk2j-$comp_name.jsonl
      /opt/venv/bin/python /opt/venv/bin/lnk2j.py -i $all_users -f jsonl |tee -a $case_dir/File_Access/LNK/lnk2j-$comp_name.jsonl
      z_lecmd_jlecmd
    fi
    if [ -f "$case_dir/File_Access/LNK/lnk2j-$comp_name.jsonl" ]; then
      /opt/venv/bin/python /usr/local/src/dfir-scripts/WinEventLogs/jsonl_to_csv.py $case_dir/File_Access/LNK/lnk2j-$comp_name.jsonl |tee $case_dir/File_Access/LNK/lnk2j-$comp_name.csv
    fi
}

#Run RegRipper plugins on the Software Registry Hive
function rip_software(){
  software_plugins="/opt/app/regripper/plugins/software"
  output_dir="$case_dir/Regripper/Software"
  mkdir -p "$output_dir"

  if [[ -f "$software_hive" && -f "$software_plugins" ]]; then
    make_green "Running RegRipper plugins on the Software Registry Hive(s)"
    plugins=()
    while IFS= read -r line; do plugins+=("$line");done < "$software_plugins"
    parallel --jobs 4 --timeout 60 --retries 2 \
    "rip.pl -r "$software_hive" -p {} >> $output_dir/{}-SOFTWARE-$comp_name.txt" :::  "${plugins[@]} " 2>>$output_dir/Software-Plugin-Process.log
  fi
    rip.pl -aT -r $software_hive | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
    reglookup-timeline -H  $software_hive 2>/dev/null|awk -F',' -v a=$comp_name '{print $1",REG,"a",,M... SOFTWARE "$3}' >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
}
#Run RegRipper plugins on the System Registry
function rip_system(){
  system_plugins="/opt/app/regripper/plugins/system"
  output_dir="$case_dir/Regripper/System"
  mkdir -p "$output_dir"
  if [[ -f "$system_hive" && -f "$system_plugins" ]]; then
    make_green "Running select RegRipper plugins on the System Registry Hive(s)"
    plugins=()
    while IFS= read -r line; do plugins+=("$line");done < "$system_plugins"
    parallel --jobs 4 --timeout 60 --retries 2 \
    "rip.pl -r "$system_hive" -p {} >> $output_dir/{}SYSTEM-$comp_name.txt" ::: "${plugins[@]}" 2>>$output_dir/System-Plugin-Process.log
  fi
  rip.pl -aT -r $system_hive | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
}

#Run select RegRipper plugins on the Security Registry
function rip_security(){
  if [ -f "$security_hive" ]; then
    output_dir="$case_dir/Regripper/Security"
    mkdir -p "$output_dir"
    cd $case_dir
    make_green "Running RegRipper plugins on the Security Registry Hive(s)"
    sleep 1
    rip.pl -f security -r $security_hive >> $output_dir/Audit-Policy-$comp_name.txt 2>>$output_dir/Security-Plugin-Process.log
    rip.pl -aT -r $security_hive | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
    reglookup-timeline -H  $security_hive 2>/dev/null|awk -F',' -v a=$comp_name '{print $1",REG,"a",,M... SECURITY "$3}' >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
  fi
}

#Run RegRipper on SAM Registry hive
function rip_sam(){
  if [ -f "$sam_hive" ]; then
    output_dir="$case_dir/User_Account_Info/Sam"
    mkdir -p "$output_dir"
    cd $mount_dir
    make_green "Searching for SAM (Regripper)"
    sleep 1
      rip.pl -r $sam_hive -a >> $output_dir/SAM-$comp_name.txt 2>>$output_dir/Sam-Plugin-Process.log
      rip.pl -aT -r $sam_hive |sed "s/|SAM||/|SAM|${comp_name}|/" >> $tempfile
      reglookup-timeline -H  $sam_hive 2>/dev/null| awk -F',' -v a=$comp_name '{print $1",REG,"a",,M... SAM "$3}' >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
  fi
}

#Run Regripper plugins on NTUSER.DAT
function rip_ntuser() {
  make_green "Running Regripper plugins on NTUSER.DAT. Standby..."
  ntuser_plugins="/opt/app/regripper/plugins/ntuser"
  output_dir="$case_dir/Regripper/NTUSER"
  mkdir -p "$output_dir"

  plugins=()
  while IFS= read -r line; do
    plugins+=("$line")
  done < "$ntuser_plugins"

  process_plugin() {
    local plugin="$1"
    local plugin_output_file="$output_dir/${plugin}-NTUSER-$comp_name.txt"

    fd --type d --max-depth 1 . "$user_dir" | while read -r user_path; do
      ntuser_file=$(fd -i "ntuser.dat" --max-depth 1 "$user_path" 2>/dev/null | head -n 1)
      user_name=$(basename "$user_path")

      if [[ -f "$ntuser_file" ]]; then
        echo "******* $user_name *******" >> "$plugin_output_file"
        rip.pl -r "$ntuser_file" -p "$plugin" >> "$plugin_output_file"
      fi
    done
  }

  # Export the function and variables and run in parallel
  export -f process_plugin
  export output_dir
  export user_dir
  export comp_name
  export tempfile

  parallel --jobs 4 --timeout 60 --retries 2 \
    process_plugin ::: "${plugins[@]}" 2>>"$output_dir/Ntuser-Plugin-Process.log"
}

function rip_usrclass(){
  make_green "Run Regripper plugins on UsrClass.dat"
  usrclass_plugins="/opt/app/regripper/plugins/usrclass"
  output_dir="$case_dir/Regripper/NTUSER"
  mkdir -p "$output_dir"

  # Initialize the plugins array
  plugins=()
  while IFS= read -r line; 
  do
    plugins+=("$line")
  done < "$usrclass_plugins"

  # Function to process a single plugin for all users
process_plugin() {
  local plugin="$1"
  local plugin_output_file="$output_dir/${plugin}-USRCLASS-$comp_name.txt"

  fd --type d --max-depth 1 . "$user_dir" | while read -r user_path; do
    ntuser_file=$(fd -i "ntuser.dat" --max-depth 1 "$user_path" 2>/dev/null | head -n 1)
    user_name=$(basename "$user_path")

    if [[ -f "$ntuser_file" ]]; then
      echo "******* $user_name UsrClass.dat *******" >> "$plugin_output_file"
      rip.pl -r "$ntuser_file" -p "$plugin" >> "$plugin_output_file"
    fi
  done
}

  # Export the function and variables and run in parallel
  export -f process_plugin
  export output_dir
  export echo user_dir
  parallel --jobs 4 --timeout 60 --retries 2 \
  process_plugin ::: "${plugins[@]}" 2>>$output_dir/Usrclass-Plugin-Process.log
}

#Run RegRipper plugins on the System Registry
function rip_system(){
  system_plugins="/opt/app/regripper/plugins/system"
  output_dir="$case_dir/Regripper/System"
  mkdir -p "$output_dir"
  if [[ -f "$system_hive" && -f "$system_plugins" ]]; then
    make_green "Running select RegRipper plugins on the System Registry Hive(s)"
    plugins=()
    while IFS= read -r line; do plugins+=("$line");done < "$system_plugins"
    parallel --jobs 4 --timeout 60 --retries 2 \
    "rip.pl -r "$system_hive" -p {} >> $output_dir/{}-SYSTEM-$comp_name.txt" ::: "${plugins[@]}" 2>>$output_dir/System-Plugin-Process.log
  fi
  rip.pl -aT -r $system_hive | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
  reglookup-timeline -H  $system_hive 2>/dev/null|awk -F',' -v a=$comp_name '{print $1",REG,"a",,M... SYSTEM "$3}' >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
}

#Run RegRipper TLN plugins on NTUSER.DAT
function rip_ntuser_tln(){
  if [ -d "$user_dir" ]; then
    make_green "Creating TLN timelines for NTUSER.DAT KEYS (Regripper)"
    sleep 1
    cd $user_dir/
    fd -i -d 2 -t f "ntuser.dat$" "$user_dir"| \
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      usrclass_file=$(find $user_dir/"$user_name"/[aA]*[aA]/[lL]*[lL]/[mM][iI]*[tT]/[wW]*[sS] -maxdepth 3 -type f 2>/dev/null| \
      grep -i -m1 "\/usrclass.dat$")
      rip.pl -aT -r "$ntuser_path" 2>/dev/null |sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
      rip.pl -aT -r "$usrclass_file" 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
      make_green "Running reglookup to timeline registry"
      reglookup-timeline -H "${ntuser_path}" 2>/dev/null|awk -F',' -v a=$comp_name -v b=$user_name '{print $1",REG,"a","b",M... NTUSER.DAT "$3}' 2>/dev/null >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
      reglookup-timeline -H "${usrclass_file}" 2>/dev/null|awk -F',' -v a=$comp_name -v b=$user_name '{print $1",REG,"a","b",M... UsrClass "$3}' 2>/dev/null >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
    done
  fi
}

#Run RegRipper on AmCache.hve and stack hashes
function extract_amcache.hve(){
  if [ -f "$amcache_hive" ]; then
    make_green "Extracting Any RecentFileCache/AmCache (amcache.py AmcacheParser)"
    rip.pl -aT -r "$amcache_hive" 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" >> $tempfile
    rip.pl -aT -r "$amcache_hive" 2>/dev/null | sed "s/|||/|${comp_name}|${user_name}|/" | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}'| sed 's/,/;/5g' >> "$case_dir/Application_Execution/Amcache/RegR-Amcache-$comp_name.csv"
    reglookup-timeline -H  "$amcache_hive" 2>/dev/null|awk -F',' -v a=$comp_name '{print $1",REG,"a",,M... AmCache "$3}' >> $case_dir/Timeline/Registry-Timeline-$comp_name.csv
    z_amcacheparser
  fi
  if [ -f "$case_dir/Application_Execution/Amcache/Amcache-RegR-$comp_name.csv" ]; then
    cat "$case_dir/Application_Execution/Amcache/Amcache-RegR-$comp_name.csv" |sed -r 's/(.*)\(/\1- /'|sed -r 's/(.*)\)/\1/'| \
    awk -F' - ' -v a=$comp_name '{print $3","$2","a}' >> "$case_dir/All_Summary/Amcache-Hashes-$comp_name.csv"
  fi
}

# Dump offline hashes and LSA secrets
function secrets_dump(){
  if [ -f "$sam_hive" ]; then
    make_green "Dumping Hashes and LSA Secrets (secrets_dump.py)"
    secretsdump.py -sam $sam_hive -system $system_hive -security $security_hive local >> $case_dir/User_Account_Info/secrets_dump-Hashes-$comp_name.txt
  fi
}

#ShellBags
function shellbags(){
  make_green "Collecting Shellbags (ripl.pl, sbecmd)"
  find "$user_dir/" -maxdepth 2 ! -type l|grep -i ntuser.dat$ |\
  while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      echo $user_name
      find $user_dir/$user_name/[aA]*[aA]/[lL]*[lL]/[mM][iI]*[tT]/[wW]*[sS] -maxdepth 3 -type f 2>/dev/null|grep -i "\/usrclass.dat$" |\
      while read d; 
      do
        rip.pl -r "$d" -p shellbags 2>/dev/null |tee $case_dir/File_Access/ShellBags/RegR-ShellBags-$user_name-$comp_name.txt
      done
    done
    z_sbecmd
}


#Timeline Windows Services
function winservices() {
  if [ -f "$system_hive" ]; then
    cd "$mount_dir" || exit
    make_green "Searching for Windows Services (winservices.py)"
    sleep 1

    # Run winservices.py and sort the output
    /opt/venv/bin/python /opt/app/dfir-scripts/Python-Registry/winservices.py "$system_hive" | sort -r \
    >> "$case_dir/Persistence/Services/winservices.py-$comp_name.csv"

    # Check if the CSV file exists and process it
    if [ -f "$case_dir/Persistence/Services/winservices.py-$comp_name.csv" ]; then
      # Process the CSV file in a single pass
      awk -F',' '
        /^[0-9]{4}/ {
          timestamp = $1
          cmd = "date -d \"" timestamp "\" +\"%s\" 2>/dev/null"
          cmd | getline tlntime
          close(cmd)
          tlninfo = "||[Service Last Write]: " $2 ";" $3 ";" $5 ";" $7 ";" $8
          print tlntime "|Svc|" ENVIRON["comp_name"] tlninfo
        }
      ' "$case_dir/Persistence/Services/winservices.py-$comp_name.csv" >> "$tempfile"
    fi

    # Prepare for Excel conversion
    winservices_csv="$case_dir/Persistence/Services/winservices.py-$comp_name.csv"
    winservices_template="/opt/app/dfir-scripts/csv2XLsheet/templates/ServicesSlicer.xltx"
    winservices_sheet="Services-Slicer"
    winservices_output="$case_dir/All_Slicers/Services-$comp_name.xlsx"

    # Convert to Excel if the CSV has at least 2 lines
    if [ "$(wc -l < "$case_dir/Persistence/Services/winservices.py-$comp_name.csv")" -ge 2 ]; then
      $csv2XL -i "$winservices_csv" -t "$winservices_template" -s "$winservices_sheet" -r 2 -o "$winservices_output"
    else
      rm "$case_dir/Persistence/Services/winservices.py-$comp_name.csv" 2>/dev/null
    fi
  fi
}

#Extract BAM
function bam_dam(){
  if [ -f "$system_hive" ]; then
    cd $mount_dir
    make_green "Extracting Windows Background Activtiy (bamdam2tln.py.py)"
    sleep 1
    /opt/venv/bin/python /opt/app/dfir-scripts/Python-Registry/bamdam2tln.py $system_hive -c >> $case_dir/Application_Execution/Bam/bamdam2tln.py-$comp_name.csv;
    if [ -f "$case_dir/Application_Execution/bamdam2tln.py-$comp_name.csv" ]; then
      /opt/venv/bin/python /opt/app/dfir-scripts/Python-Registry/bamdam2tln.py $system_hive >> $tempfile
    fi
  fi
}

#Timeline Prefetch and extract metadata
function prefetch_extract() {
  cd "$mount_dir" || exit
  prefetch=$(fd -i -d 1 -t d --glob "*prefetch*" "$windir")

  if [ "$prefetch" ]; then
    rm -f /tmp/prc.txt 2>/dev/null
    make_green "Searching for Prefetch Files (prefetchruncounts.py)"

    # Run prefetchruncounts.py in parallel for each prefetch directory
    echo "$prefetch" | parallel -j 4 --no-notice \
      "/opt/venv/bin/python /opt/app/dfir-scripts/prefetchruncounts/prefetchruncounts.py {} >> $case_dir/Application_Execution/Prefetch/prefetchruncounts-$comp_name.csv"

    echo "$prefetch" | parallel -j 4 --no-notice \
      "/opt/venv/bin/python /opt/app/dfir-scripts/prefetchruncounts/prefetchruncounts.py {} -t >> /tmp/prc.txt"

    # Process /tmp/prc.txt in a single pass
    if [ -f "/tmp/prc.txt" ]; then
      awk -F',' '
        /^[0-9]{4}/ {
          timestamp = $1
          cmd = "date -d \"" timestamp "\" +\"%s\" 2>/dev/null"
          cmd | getline tlntime
          close(cmd)
          if (tlntime != "") {
            tlninfo = "[Program Execution] PF_File:" $3 " Executable:" $4 " Run Count:" $2 " Volumes" $5
            print tlntime "|prefetch|" ENVIRON["comp_name"] "||" tlninfo
          }
        }
      ' /tmp/prc.txt >> "$tempfile"
    fi

    # Clean up temporary file
    rm -f /tmp/prc.txt

    # Prepare for Excel conversion
    prc_csv="$case_dir/Application_Execution/Prefetch/prefetchruncounts-$comp_name.csv"
    prc_template="/opt/app/dfir-scripts/csv2XLsheet/templates/PrefetchSlicer.xltx"
    prc_sheet="Prefetch-Table"
    prc_output="$case_dir/All_Slicers/prefetchruncounts-$comp_name.xlsx"

    # Convert to Excel if the CSV has at least 2 lines
    if [ "$(wc -l < "$prc_csv")" -ge 2 ]; then
      $csv2XL -i "$prc_csv" -t "$prc_template" -s "$prc_sheet" -r 2 -o "$prc_output"
    else
      rm -f "$prc_csv" 2>/dev/null
    fi
  fi
}

#Extract Windows.edb Windows-Gather.db
function parse_windows_index(){
  cd $mount_dir
  win_index=$(find $mount_dir -maxdepth 4 -iwholename "*ProgramData/Microsoft/Search/Data*" )
  if [ -d "$win_index" ]; then
  make_green "Extracting Windows Indexes (Sidr)"
    sidr $win_index  -o $case_dir/File_Access/Windows_Index
  fi
  find  $case_dir/File_Access/Windows_Index -type f | \
  while read d; 
  do
    index_file=$(echo "$d" |sed 's/json$/csv/')
    /opt/venv/bin/python /usr/local/src/dfir-scripts/WinEventLogs/jsonl_to_csv.py $d |tee $index_file
  done
}

#Timeline recycle.bin metadata
function rec_bin(){
  if  [ "$(ls -A /$mount_dir/\$Recycle.Bin 2>/dev/null)" ]; then
    make_green "Parsing \$Recycle.Bin (recbin2tln, RBCmd)"
    /opt/app/dfir-scripts/shellscripts/recbin2tln.sh . -c |sed "s/cle,,/cle,$comp_name|/" >> $case_dir/File_System/Deleted_Files/Recycled-$comp_name.csv
    /opt/app/dfir-scripts/shellscripts/recbin2tln.sh . |sed "s/cle||/cle|$comp_name|/" >> $tempfile
    z_rbcmd
  fi
}

function browser_extract(){
  mkdir $case_dir/Browser_Activity/$comp_name
  /opt/app/dfir-scripts/shellscripts/firefox2tln.sh -c $user_dir >> $case_dir/Browser_Activity/Firefox-$comp_name.csv
  /opt/app/dfir-scripts/shellscripts/firefox2tln.sh $user_dir  >> $tempfile
  /opt/app/dfir-scripts/shellscripts/chrome2tln.sh -c $user_dir >> $case_dir/Browser_Activity/Chrome-$comp_name.csv
  /opt/app/dfir-scripts/shellscripts/chrome2tln.sh $user_dir  >> $tempfile

  # Run Hindsight on Users Directory
  echo "Running Hindsight on $user_dir Directory"
  mkdir -p $case_dir/Browser_Activity/tmp
  /opt/venv/bin/hindsight.py -i $user_dir -o $case_dir/Browser_Activity/Hindsight -l "$case_dir/Browser_Activity/tmp/hindsight.log" --temp_dir $case_dir/Browser_Activity/tmp
  [ -f $case_dir/Browser_Activity/Hindsight.xlsx ] && \
  mv $case_dir/Browser_Activity/Hindsight.xlsx $case_dir/Browser_Activity/Hindsight-$comp_name.xlsx

  web_cachev=$(find $user_dir/*/AppData/Local/Microsoft/Windows/WebCache -maxdepth 2 -type f 2>/dev/null|grep -i -m1 "WebcacheV" )
  if [  -f "$web_cachev" ]; then
    echo "Extracting any IE WebcacheV0x.dat files (esedbexport)"
    find "$user_dir" -maxdepth 2 ! -type l|grep -i ntuser.dat$ |\
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      find $user_dir/$user_name/AppData/Local/Microsoft/Windows/WebCache -maxdepth 2 -type f -iname "WebcacheV*.dat" 2>/dev/null |\
      while read d;
      do
        /usr/bin/esedbexport -t $case_dir/Browser_Activity/esedbexport-Webcachev01.dat-$user_name "$d" 2>/dev/null;
      done
      find $case_dir/Browser_Activity/esedbexport-Webcachev01.dat-$user_name.export -type d 2>/dev/null| \
      while read dir;
      do
        grep -hir Visited: $dir |awk '{ s = ""; for (i = 9; i <= NF; i++) s = s $i " "; print s }'|awk -v last=26 '{NF = last} 1' \
        >> $case_dir/Browser_Activity/Webcachev01.dat-$comp_name.csv
        cat "$case_dir/Browser_Activity/Webcachev01.dat-$comp_name.csv" | \
        grep -aP ".com/search\?q"\["\W"] | awk -v FS="([hH][tT][tT][Pp]|&)" '{print "http"$2}' \
        >> $case_dir/Browser_Activity/$user_name-IE-Edge-Searches.csv
      done
    done
  fi  
  fd --type f -e csv . $case_dir/Browser_Activity/ |grep -E Chrome\|Firefox | while read d;
  do
    cat $d| grep -aP ".com/search\?q"\["\W"] |awk -v FS="([hH][tT][tT][Pp]|&)" '{print "http"$2}' >> $case_dir/Browser_Activity/Browser-Search-$comp_name.csv
  done
  grep -hir "file:///"  $case_dir/Browser_Activity/$comp_name/ese*/* 2>/dev/null| \
  awk -F' ' '{print $33","$34","$10","$11","$12","$13","$14","$15","$16","$17","$18","$19","$20","$21","$22","$23","$24","$25","$26","$27","$28","$29}' >> $case_dir/File_Access/MS-Browser-FileAccess-$comp_name.csv
}

function srum_dump(){
  sru_file=$(find $winsysdir/[S,s][R,r][U,u] -maxdepth 2 -type f -iname "srudb.dat" 2>/dev/null )
  if [ -f "$sru_file" ]; then
    make_green "Extracting $sru_file file (srum_dump2.py)
    Standby...  This might take a while"
    /opt/venv/bin/python /opt/app/srum-dump/srum_dump2.py --SRUM_INFILE "$sru_file" \
    --XLSX_OUTFILE $case_dir/Application_Execution/SRUM/srum_dump-$comp_name.xlsx -r $regdir/SOFTWARE \
    -q -t /opt/app/srum-dump/SRUM_TEMPLATE2.xlsx
  fi
}

function kstrike_current.mdb(){
  current_mdb=$(find $winsysdir/[L,l]*[S,s]/[S,s][U,u][M,m] -type f 2>/dev/null | grep -i current.mdb$)
  if [ -f "$current_mdb" ]; then
    cd $mount_dir
    make_green "Parsing UserAccessLog (Current.mdb) with KStrike.py"
    /opt/venv/bin/python /opt/app/KStrike/KStrike.py "$current_mdb" > $case_dir/Network_Info/UserAccessLog/Kstrike-$comp_name.txt
  fi
}

#Run Bits_Parser.py and process Microsoft-Windows-Bits-Client\%4Operational.evtx
function bits_parser(){
  if [ -d "$mount_dir/ProgramData/Microsoft/Network/Downloader/" ]; then
    make_green "Searching and extracting qmgr.db (BitsParser.py)"
    /opt/venv/bin/python /opt/app/BitsParser/BitsParser.py -i \
    $mount_dir/ProgramData/Microsoft/Network/Downloader/ --carvedb --carveall 2>/dev/null \
    >> $case_dir/Persistence/BITS/BitsParser.py-$comp_name.json
  fi
}

#copy powershell console log
function get_ps_console_log(){
  console_log=$(find $user_dir/*/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt 2>/dev/null)
  if [ -f "$console_log" ]; then
    make_green "Searching for PowerShell Console Log"
    cd $user_dir/
    fd -i -d 2 -t f "ntuser.dat$" "$user_dir"|\
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      cat "$user_dir/$user_name/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt" 2>/dev/null >> $case_dir/Scripting/PowerShell/$comp_name-$user_name-ConsoleHost_history.txt
     done
  fi
}
 
#Parse Windows History File
function extract_winactivities(){
  winactivities_file=$(fd -i -d 6 -t f "ActivitiesCache.db$" $user_dir)
  if [ -f "$winactivities_file" ]; then
    make_green "Searching for ActivitiesCache.db"
    cd $user_dir/
    fd -i -d 2 -t f "ntuser.dat$" "$user_dir" | \
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      fd -i -d 3 -t f "ActivitiesCache.db$" "$user_dir/$user_name/AppData/Local/ConnectedDevicesPlatform/" 2>/dev/null | \
      while read d;
      do
        cd $case_dir
        sqlite3 "$d" ".read /opt/app/kacos2000/WindowsTimeline/WindowsTimeline.sql" 2>/dev/null >> $case_dir/Timeline/WinActivitiesCache/WindowsTimeline.sql-$user_name-$comp_name.csv
        /opt/zimmermantools/WxTCmd/WxTCmd -f $d --csv $case_dir/Timeline/WinActivitiesCache/$user_name
      done
    done
    fd -i -t f "WindowsTimeline.sql" "$case_dir/Timeline/WinActivitiesCache/" 3>/dev/null | \
    while read f;
    do
      user_name=$(echo "$f"|sed 's|.*/||' |awk -F'\\-' '{print $2}')
      cat "$f" 2>/dev/null| \
      awk -F'|' '{print $3}' | awk -F'\' '{print $NF}'|sort |uniq -c|sort -rn >> $case_dir/All_Summary/WinActivitiesCache-stats-$comp_name.csv
    done
  fi
}

extract_PCA(){
  cd $mount_dir
  if [ -f $windir/appcompat/pca/PcaAppLaunchDic.txt ]; then
    make_green "Searching for Windows 11 Program Compatibility Assistant"
    cat $windir/appcompat/pca/PcaAppLaunchDic.txt | \sed 's|\\|\\\\|g' |\
    while read d;
    do
      timestamp=$(echo "$d" | awk -F'|' '{print $2}')
      pca_path=$(echo "$d" | awk -F'|' '{print $1}')
      tln_time=$(date -d "$timestamp"  +"%s" 2>/dev/null)
      tl_time=$(echo $tln_time | awk '{$0=strftime("%Y-%m-%d %H:%M:%S",$0)}{print $0}')
      tln_line=$tln_time"|PCAdic|"$comp_name"||Program Execution:"$pca_path
      tl_line=$tl_time",PCA,"$comp_name",,Program Execution:"$pca_path
      echo $tl_line >> $case_dir/Application_Execution/PCA/PcaAppLaunchDic.csv
      echo $tln_line  >> $tempfile
    done
    find $windir/appcompat/pca/PcaGeneralDb[0-9].txt |\
    while read d;
    do
      file_name=$(echo "$d" |awk -F'pca/' '{print $2}')
      echo  "Runtime,Run_status,Exe_path,Description,Software_vendor,File_version,ProgramId,Exitcode" >> $case_dir/Application_Execution/PCA/$file_name
      cat "$d"| tr -d '\000' | sed 's/|/,/g' >> $case_dir/Application_Execution/PCA/$file_name
      cat "$d" | sed 's|\\|\\\\|g' 2>/dev/null|\
      while read f;
      do
        timestamp=$(echo "$f" | awk -F'|' '{print $1}')
        pca_path=$(echo "$f" | awk -F'|' '{print $3}')
        tln_time=$(date -d "$timestamp"  +"%s" 2>/dev/null)
        tln_line=$tln_time"|PCAdb|"$comp_name"||Program Execution:"$pca_path
        echo $tln_line  >> $tempfile
      done
    done
  fi
}

# Extract WindowsEvent Logs to jsonl
function evtx_dump_json(){
  if [ "$evtxdir" ]; then
    cd $mount_dir
    make_green "Dumping Windows Event Logs to jsonl (evtx_dump)"
    sleep 1
    mkdir -p "$case_dir/WindowsEventLogs/evtx_dump_$comp_name"
    find $evtxdir -type f 2>/dev/null -size +70k $evtx_max -name '*.evtx' | \
    grep -vi Archive | \
    while read d;
    do
      evtx_file=$(basename "$d")
      echo "Dumping $evtx_file to jsonl"
      time evtx_dump "$d" --validate-checksums -t 1 -o jsonl -f "$case_dir/WindowsEventLogs/evtx_dump_$comp_name/$evtx_file-$comp_name.jsonl"
    done
  fi
}

function evtx_hussar(){
  if [ "$evtxdir" ]; then
        mkdir -p "$case_dir/WindowsEventLogs/EvtxHussar_$comp_name"
    cd /usr/local/src/EvtxHussar/
    find $evtxdir -type f |grep -Ei system.evtx\|security.evtx\|firewall\|defender|while read d; \
    do
    ./EvtxHussar -m /usr/local/src/EvtxHussar/maps -t /usr/local/src/EvtxHussar/templates "$d" -o $case_dir/WindowsEventLogs/EvtxHussar_$comp_name;done
  fi
}


function run_hayabusa(){
  if [ "$evtxdir" ]; then
    cd $evtxdir
    make_green "Scanning for Sigma Alerts in EVTX files (Hayabusa)"
    mkdir -p "$case_dir/Sigma_Alerts/Hayabusa_$comp_name"
    cd /opt/app/Hayabusa
    hayabusa json-timeline -N --no-wizard  -p all-field-info-verbose --disable-abbreviations -d $evtxdir -L -o  $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl
    sleep .5
  fi
  if [ -f $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl ]; then
   #Summary of Hayabusa Sigma Scan
   cat $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level != "info" )| "\(.Level),\(.Computer),\(.RuleTitle),\(.EventID),\(.Channel)"'|sort |uniq -c|sort -rn|sed 's/ "/,/g'|sed 's/"$//g' | \
   tee $case_dir/Sigma_Alerts/Hayabusa-Count-$comp_name.csv && sed -i '1i Count,Level,Computer,RuleTitle,EventID,Channel' $case_dir/Sigma_Alerts/Hayabusa-Count-$comp_name.csv
   # Critical, High and Medium Alerts from Hayabusa
   cat $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "crit" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//' | \
   tee $case_dir/Sigma_Alerts/Hayabusa-AlertsDetail-$comp_name.csv

   cat $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "high" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//'| \
   tee $case_dir/Sigma_Alerts/Hayabusa-AlertsDetail-$comp_name.csv

   cat $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl | \
   jq 'select (.Level == "med" ) | "\(.Timestamp),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel)"' | sort|sed 's/^"//'|sed 's/"$//'| \
   tee $case_dir/Sigma_Alerts/Hayabusa-AlertsDetail-$comp_name.csv

   [ -f "tee $case_dir/Sigma_Alerts/Hayabusa-AlertsDetail-$comp_name.txt" ] && sed -i '1i Timestamp,EventID,Level,Computer,RuleTitle,Channel' tee $case_dir/Sigma_Alerts/Hayabusa-AlertsDetail-$comp_name.csv

   cat $case_dir/Sigma_Alerts/Hayabusa-$comp_name.jsonl | \
   jq 'select(.Level != "info")|",\(.Timestamp |.[:10]),\(.EventID),\(.Level),\(.Computer),\(.RuleTitle),\(.Channel),\(.AllFieldInfo)"' |sed 's/ ,/,/g' | \
   tee $case_dir/Sigma_Alerts/Hayabusa-Alerts-All-Fields-byDate-$comp_name.csv
   [ -f "$case_dir/Sigma_Alerts/Hayabusa-Alerts-byDate-$comp_name.csv" ] && sed -i '1i Count,Date,EventID,Level,Computer,RuleTitle,Channel' $case_dir/Sigma_Alerts/Hayabusa-Alerts-byDate-$comp_name.csv
 fi
}

function parse_evtx_jsonl(){
  # Extract Powershell Logs
  find $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ -type f 2>/dev/null | \
  grep Microsoft-Windows-PowerShell%4Operational.evtx-$comp_name.jsonl | \
  while read d;
  do
    cat "$d" |jq -j '.Event|select(.EventData.ScriptBlockText !=null)|.System.Computer,.System.TimeCreated."#attributes".SystemTime,.EventData.Path,.System.Security."#attributes".UserID,.EventData.ScriptBlockText,.System.Channel' >> $case_dir/Scripting/PowerShell/PowerShellScriptBlocks-$comp_name.txt
  done
  find $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ -type f 2>/dev/null | \
  grep Windows.PowerShell.evtx-$comp_name.jsonl| \
  while read d;
  do
    cat "$d" 2>/dev/null | \
    jq  '.Event|select(.EventData.Data."#text"!=null)|.System.Computer,.System.TimeCreated."#attributes".SystemTime,.EventData.Data,.System.Channel' >> $case_dir/Scripting/PowerShell/PowerShell-HostApplication-$comp_name.txt
  done
  # Get IPv4 Addresses in EVTX files
  if  [ "$(ls -A $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ 2>/dev/null)" ]; then
    make_green "Extracting IP v4 Addresses in EVTX files (ipv4inevtx.py)"
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/ipv4inevtx.py -e -d $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ |tee $case_dir/All_Summary/IPv4-Addresses-in-evtx-$comp_name.csv
  fi

# Summary of all Windows Event Logs
# Bash adaptation of PowerShell script by Gtworek Get-OldestEvents.ps1
  if  [ "$(ls -A $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ 2>/dev/null)" ]; then
    make_green "Create summary of Windows Events (adaptation of Get-OldestEvents.ps1)"
    cd $evtxdir
    ls $evtxdir |while read d;
    do
      file_name="$d"
      file_size=$(stat -c %s "$d")
      find $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ -type f |grep "$d"-$comp_name.jsonl | \
      while read f;
        do
          first_event=$(cat "$f" |grep -m1 ""|jq -r '.Event.System.TimeCreated."#attributes".SystemTime')
          last_event=$(cat "$f" | tail -1 |jq -r '.Event.System.TimeCreated."#attributes".SystemTime')
          total_events=$(cat "$f" | wc -l)
          echo "$file_name,$file_size,$first_event,$last_event,$total_events"|grep -v ,, >> $case_dir/All_Summary/Winevtx-info-$comp_name.csv
        done
    done
  fi
  if  [ $case_dir/All_Summary/Winevtx-info-$comp_name.csv ]; then
    sed -i '1i EventLogName,Size,FirstEvent,LastEvent,TotalEvents' $case_dir/All_Summary/Winevtx-info-$comp_name.csv
  fi

# Get Summary from Security.evtx
  find $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ -type f 2>/dev/null | \
  grep -i \/Security.evtx-$comp_name.jsonl| \
  while read d;
  do
    echo "SECURITY.EVTX EVENT COUNT" >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    /opt/app/dfir-scripts/WinEventLogs/jq/security.evtx.count.sh "$d" \
    >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    echo "*********************************************************
    ">> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    echo "SECURITY.EVTX LOGIN TYPES" >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    /opt/app/dfir-scripts/WinEventLogs/jq/logintypescount.sh "$d" \
    >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    echo "*********************************************************
    ">> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    echo "SECURITY.EVTX NEW PROCESSES" >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    /opt/app/dfir-scripts/WinEventLogs/jq/newprocesscount.sh "$d" \
    >> $case_dir/All_Summary/Security.evtx-stats-$comp_name.txt
    echo "SECURITY.EVTX FAILED LOGINS" >> $case_dir/All_Summary/failed-logins-$comp_name.txt
    /opt/app/dfir-scripts/WinEventLogs/jq/failed_logins.sh  "$d" \
    >> $case_dir/All_Summary/failed-logins-$comp_name.txt
    echo "SECURITY.EVTX EXPLICIT LOGINS EID4648" \
    >> $case_dir/All_Summary/explicit-logins-$comp_name.txt
    /opt/app/dfir-scripts/WinEventLogs/jq/explicit_logins.sh  "$d" \
    >> $case_dir/All_Summary/explicit-logins-$comp_name.txt
  done

  # Create CSV of Task Scheduler from Evtx and create a summary
  task_sched="$case_dir/WindowsEventLogs/evtx_dump_$comp_name/Microsoft-Windows-TaskScheduler%4Operational.evtx-$comp_name.jsonl"
  if [ -f "${task_sched}" ]; then
    make_green "Searching for Scheduled Task... (parse_jsonl_tasks.py)"
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_jsonl_tasks.py ${task_sched} >> $case_dir/Persistence/ScheduledTasks/tasks_evtx.py-$comp_name.csv;
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_jsonl_tasks.py -s ${task_sched} >> $case_dir/All_Summary/tasks_evtx_stacked.py-$comp_name.csv;
    task_csv=" $case_dir/Persistence/ScheduledTasks/tasks_evtx.py-$comp_name.csv "
    task_template="/opt/app/dfir-scripts/csv2XLsheet/templates/TaskScheduleSlicer.xltx"
    task_sheet="Task-Slicer"
    task_output="$case_dir/All_Slicers/ScheduledTasks-$comp_name.xlsx"
    if [ $(wc -l < $case_dir/Persistence/ScheduledTasks/tasks_evtx.py-$comp_name.csv) -ge 2 ]; then
      $csv2XL -i $task_csv -t $task_template -s $task_sheet -r 2 -o $task_output
    else
      rm $case_dir/Persistence/ScheduledTasks/jobsparser.py-$comp_name.csv 2> /dev/null
    fi
  fi
  cat $case_dir/Persistence/ScheduledTasks/evtx_tasks.py-$comp_name.csv 2>/dev/null| \
  grep -E TaskStartEvent\|TaskSuccessEvent\|TaskRegisteredEvent |\
  while read d;
  do
    tlntime=$(echo $d|awk -F',' '{print $1}'| xargs -i date -d "{}" "+%s")
    evtxinfo=$(echo $d|awk -F"," '{print $2";"$6";"$3}')
    [ "$tlntime" != "" ] && echo $tlntime"|SchTask|"$comp_name"||"$evtxinfo >> $tempfile
  done

  #Microsoft-Windows-Bits-Client\%4Operational.evtx
  bits_client="$evtxdir/Microsoft-Windows-Bits-Client%4Operational.evtx"
  # extract all Bits Events to csv and then write to TLN temp file
  if [ -f "$bits_client" ]; then
    make_green "Searching for BITS Transactions... (parse_evtx_BITS.py)"
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_evtx_BITS.py "$bits_client" >> $case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv
    sleep 1
    cat $case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv |\
    while read d;
    do
      tlntime=$(echo $d|awk -F',' '{print $1}'| xargs -i date -d "{}" "+%s" 2>/dev/null)
      evtxinfo=$(echo $d|awk -F"," '{$1=""}1')
      [ "$tlntime" != "" ] && echo $tlntime"|BITS|"$comp_name"||"$evtxinfo >> $tempfile
    done
    bits_csv="$case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv "
    bits_template="/opt/app/dfir-scripts/csv2XLsheet/templates/BitsSlicer.xltx"
    bits_sheet="BITS-Slicer"
    bits_output="$case_dir/All_Slicers/BITS-$comp_name.xlsx"
    if [ $(wc -l <$case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv) -ge 2 ]; then
      $csv2XL -i $bits_csv -t $bits_template -s $bits_sheet -r 2 -o $bits_output
    else
      rm $case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv 2> /dev/null
    fi
  fi

  ## Write Summary
  if [ -f $case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv ]; then
    echo "WINDOWS BITS EVENT SUMMARY

 COUNT,EVENTID,DESCRIPTION,COMPUTER,PROCESSID,USER,JOBTITLE,URL,BYTES_IN,BYTES_OUT,OWNER" >> $case_dir/All_Summary/BITS-stacked-$comp_name.csv
    cat $case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv |grep ^[1-9] | \
    awk -F',' '{print $2","$3","$4","$5","$8","$9","$10","$14","$15","$17}' |sort |uniq -c |sort -rn >> $case_dir/All_Summary/BITS-stacked-$comp_name.csv
  fi
}

function rdp_parse(){
  #Find RDP Connections
  if [ "$(ls "$evtxdir" | grep -Ei TerminalServices\|RdpCore 2>/dev/null)" ]; then
  make_green "Searching for RDP Sessions (parse_evtx_RDP.py)"
  /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/parse_evtx_RDP.py $evtxdir \
  >> $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv;
  /opt/app/dfir-scripts/WinEventLogs/RDP_Diagram.sh -f $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv \
  -o $case_dir/All_Summary/RDP_Diagram.sh-$comp_name.png
  cat $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv|\
  grep -E  \,21\,\|\,23\,\|\,24\,\|\,25\,\|\,1149\,\|\,98\,\|\,131\,\|\,140\,\|\,1102\|\,1105\,\|\,1029 |\
  while read d;
    do
      timestamp=$(echo $d| awk -F',' '{print $1}'| \
      grep -Eo '^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) (2[0-3]|[01][0-9]):[0-5][0-9]:[0-5][0-9]')
      [ "$timestamp" != "" ] && tlntime=$(date -d "$timestamp"  +"%s" 2>/dev/null)
      evtxinfo=$(echo $d|awk -F"," '{$1=""}1')
      [ "$timestamp" != "" ] && echo $tlntime"|RDP|"$comp_name"||"$evtxinfo >> $tempfile
    done
  fi

  if [ -f $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv ]; then
    echo "WINDOWS RDP CONNECTION SUMMARY

   COUNT,EVENTID,DESCRIPTION,COMPUTER,DOMAIN,USER,HOST/IP_ADDRESS,SESSION,DIRECTION" >> $case_dir/All_Summary/RDP-stacked-"$comp_name".csv
    cat $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv | grep [1-9] |awk -F',' '{print ","$5","$6","$7","$8","$9","$10","$11}' |\
    sort  |uniq -c |sort -rn >> $case_dir/All_Summary/RDP-stacked-"$comp_name".csv
    rdp_csv="$case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv "
    rdp_template="/opt/app/dfir-scripts/csv2XLsheet/templates/RDPSlicer.xltx"
    rdp_sheet="RDP-Slicer"
    rdp_output="$case_dir/All_Slicers/RDP-$comp_name.xlsx"
    if [ $(wc -l <$case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv) -ge 2 ]; then
      $csv2XL -i $rdp_csv -t $rdp_template -s $rdp_sheet -r 2 -o $rdp_output
    else
      rm $case_dir/WindowsEventLogs/RDP/parse_evtx_RDP.py-$comp_name.csv 2> /dev/null
    fi
  fi
}

#function zircolite_evtx(){
#  if [ -d "$case_dir/WindowsEventLogs/evtx_dump_$comp_name/" ]; then
#    make_green "Scanning for Sigma Alerts in EVTX files (Zircolite)"
#    zpath="/opt/app/Zircolite"
#    find $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ -type f 2>/dev/null | \
#    grep -Ei sysmon.evtx.jsonl$\|\/Security.evtx.jsonl$\|\/Application.evtx.jsonl$\|\/System.evtx.jsonl$\|PowerShell\|Defender\|DNS\|Windows-Bits\|Windows-Smb\|TaskScheduler\|firewall| \
#    while read d;
#    do
#      evtx_jsonl=$(echo "$d" |awk -F"evtx_dump_$comp_name/" '{print $NF}')
#      /opt/venv/bin/python $zpath/zircolite.py -j -e "$d" -r $zpath/rules/rules_windows_generic_full.json -c $zpath/config/fieldMappings.json --csv -o #$case_dir/Sigma_Alerts/Zircolite-"$evtx_jsonl"-$comp_name.csv -l $case_dir/Sigma_Alerts/Zircolite-log-$comp_name.txt
#    done
#    sleep .5
#    header="COUNT,LEVEL,TITLE,DESCRIPTION"
#    result=$(cat $case_dir/Sigma_Alerts/*.json 2>/dev/null |jq -r '.[]|select(.title!="")|"\(.count),\(.rule_level),\(.title),\(.description)"'|grep -v null,null,null|sort -rn)
#    [ "$result" != "" ] && printf "%s\n%s"  ${header} "${result}"|column -t -s "," >> $case_dir/All_Summary/Zircolite-stats-"$comp_name".csv
#  fi
#}

#Extract MFT to body file and then to TLN and csv files
function analyze_mft(){
  if [ -f "$mount_dir/\$MFT" ]; then
    cd $mount_dir
    make_green "Timelining \$MFT Standby...(analyzeMFT.py)"
    [ -f "\$MFT" ] && \
    time /usr/local/src/analyzeMFT/analyzeMFT.py -p -f \$MFT --bodyfull --bodyfile=$case_dir/File_System/MFT/analyzeMFT-$comp_name.body
    [ -f $case_dir/File_System/MFT/analyzeMFT-$comp_name.body ] && make_green "Standby...(bodyfile.pl)"  && \
    time bodyfile.pl -f $case_dir/File_System/MFT/analyzeMFT-$comp_name.body -s $comp_name | \
    sort -rn >> $timeline_dir/TLN/MFT-Timeline-$comp_name.TLN && \
    make_green "Creating Timelines Standby..." && \
    cat $timeline_dir/TLN/MFT-Timeline-$comp_name.TLN | \
    awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}' | sed 's/,/;/5g' \
    >> $timeline_dir/MFT-Timeline-$comp_name.csv
    [ -f timeline_dir/TLN/MFT-Timeline-$comp_name.TLN ] && make_green "Finding interesting files" && \
    grep -Ei \\.xlsx$\|\\.docx$\|\\.ps1$\|\\.pptx$\|\\.tmp$\|\\.rar$\|\\.bat$\|\\.cmd$\|\\.vba$\|\\.vbe$\|\\.vbs$\|\\.zip$\|\\.dmp$ $timeline_dir/TLN/MFT-Timeline-$comp_name.TLN 2>/dev/null | tee $tempfile;
    [ -f $timeline_dir/MFT-Timeline-$comp_name.csv ] && make_green "Finding Volitile files" && \
    grep -Ei hiberfil.sys$\|pagefile.sys$\|swapfile.sys$\|"\.dmp$" $timeline_dir/MFT-Timeline-$comp_name.csv >> $case_dir/File_System/Volatile/Volatile-$comp_name.csv && \
    grep -Ei \\.ps1$\|\\.bat$\|\\.cmd$\|\\.vba$\|\\.vbe$\|\\.vbs$ $timeline_dir/Triage-Timeline-$comp_name.csv 2>/dev/null >> $case_dir/Scripting/Scripts-$comp_name.csv;
    tln_csv="$timeline_dir/MFT-Timeline-$comp_name.csv"
    tln_template="/usr/local/src/dfir-scripts/csv2XLsheet/templates/TLNSlicer.xltx"
    tln_sheet="TLN-Slicer"
    tln_output="$case_dir/All_Slicers/MFT-Timeline-$comp_name.xlsx"
    if [ $(wc -l <$timeline_dir/MFT-Timeline-$comp_name.csv) -ge 2 ]; then
      $csv2XL -i $tln_csv -t $tln_template -s $tln_sheet -r 2 -o $tln_output
    else
      rm $timeline_dir/MFT-Timeline-$comp_name.csv 2> /dev/null
    fi
  fi
}

#Find Deleted Files
function dump_mft(){
  if [ -f "$mount_dir/\$MFT" ]; then
    make_green "Extracting MFT (MFT_Dump)"
    mft_dump \$MFT -o csv -f $case_dir/File_System/MFT/MFT_Dump-$comp_name.csv
    #Find Unallocated files
    make_green "Locating Unallocated files"
    cat $case_dir/File_System/MFT/MFT_Dump-$comp_name.csv| \
    awk -F',' '{if($12 =="true" && $11=="false") print substr($16,1,19)",UNALLOCATED,,,FILE Last Write: FN="substr($20,1,19)";"$22;
    else if($12 =="true" && $11=="true") print substr($16,1,19)",UNALLOCATED,,,DIRECTORY Last Write: FN="substr($20,1,19)";"$22;}'| \
    sed 's/T/ /1' |sed "s/UNALLOCATED,,,/UNALLOCATED,${comp_name},,/"|grep -v ^, >> $case_dir/File_System/Deleted_Files/MFT-UNALLOCATED-$comp_name.csv
  fi
  #find AlternateDataStreams
  if [ -f "$case_dir/File_System/MFT/MFT_Dump-$comp_name.csv" ]; then
    make_green "Locating Files with Alternate Data Streams (ADS)"
    cat $case_dir/File_System/MFT/MFT_Dump-$comp_name.csv| \
    awk -F',' '{if($13 =="true") print substr($16,1,19)",ADS,,,FILE Last Write: FN="substr($20,1,19)";"$22;}' \
    | sed 's/T/ /1' |sed "s/,,,/,${comp_name},,/" |grep -P ^[0-9]{4} >> $case_dir/File_System/AlternateDataStreams/AlternateDataStreams-$comp_name.csv
  fi
}

#Consolidating TLN Output and consolidating timelines
function cp_registry_vals(){
  fd . -e txt  $case_dir/Regripper |grep -i winver |while read d; do cp "$d" $case_dir/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei networ\|NIC2\|shares\|ips\|mndmru\|logonstats\|netsh\|macaddr\|routes |while read d; do cp "$d" $case_dir/Network_Info/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei listsoft\|uninstall\|msis |while read d; do cp "$d" $case_dir/Installed_Software/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei appcompatflags\|appcertdlls\|appinitdlls\|appkeys\|appx\|cached\|calibrator\|clsid\|environment\|imagefile\|inprocserver\|killsuit\|ntds\|outlook_homepage\|pendinggpos\|powershellcore\|printdemon\|printmon\|runonceex\|runvirtual\|securityproviders\|shellfolders\|wab\|wow64 |while read d; do cp "$d" $case_dir/Persistence/Registry/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei cmdproc\|environment\|mmo\|profiler\|runonceex\|run\|svcdll\|termserv\|thispcpolicy|while read d; do cp "$d" $case_dir/Application_Execution/Registry_AutoStart/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei adobe\|disablemru\|mndmru\|mpmru\|runmru\|wordwheelquery\|recentdocs\|msoffice\photos\|comdlg32\|typedpaths\|Typedurls\|typedurlstime\|winrar\|winzip\|winscp\|tsclient |while read d; do cp "$d" $case_dir/File_Access/Registry_MRU/;done
  fd . -e txt  $case_dir/Regripper |grep -Ei cmd_shell\|appcertdll\|dcom  |while read d; do cp "$d" $case_dir/Registry_Settings/ ;done
  fd . -e txt  $case_dir/Regripper |grep -i clsid |while read d; do cp $d $case_dir/Registry_Settings/CLSID/ 2>>/dev/null;done
  cp $case_dir/Regripper/Security/Audit-Policy-$comp_name.txt $case_dir/Registry_Settings/Audit_Policy/Audit-Policy-$comp_name.txt 2>>/dev/null
  cp $case_dir/User_Account_Info/Sam/SAM-$comp_name.txt $case_dir/Regripper/Sam/SAM-$comp_name.txt 2>/dev/null
  fd . -e txt  $case_dir/Regripper |grep -iE logons\|profilelist\|lastloggedon\|profiler |while read d; do cp $d $case_dir/User_Account_Info/ 2>>/dev/null;done
  fd . -e txt  $case_dir/Regripper |grep -iE pslogging\|execpolicy\|powershellcore |while read d; do cp $d  $case_dir/Scripting/PowerShell/ 2>>/dev/null;done
  fd . -e txt  $case_dir/Regripper |grep -iE portdev\|usb\|wpdusenum\|devclass |while read d; do cp $d  $case_dir/USB 2>>/dev/null;done
  fd . -e txt  $case_dir/Regripper |grep -iE cmd_shell\|dcom\|defender\|disablemru\|imagefile\|exefile\|wbem\|uacbypass\|backuprestore\|termserv\|disableremotescm\|rdpport\|remoteaccess\|appcompatflags |while read d; do cp $d  $case_dir/Registry_Settings/ 2>>/dev/null;done
}

function consolidate_timeline(){
  if [ -f "$tempfile" ]; then
    cat $tempfile | sort -rn |uniq >> $timeline_dir/TLN/Triage-Timeline-$comp_name.TLN
    cat $tempfile |awk -F'|' '{$1=strftime("%Y-%m-%d %H:%M:%S",$1)}{print $1","$2","$3","$4","$5}'|sort -rn | uniq| grep -va ",,,,"| \
    sed 's/,/;/5g' |tee -a $timeline_dir/Triage-Timeline-$comp_name.csv
    cat $timeline_dir/Triage-Timeline-$comp_name.csv|grep -ia ",alert," >> $case_dir/Sigma_Alerts/RegRipperAlerts-$comp_name.csv
  fi
  if [ -f "$case_dir/File_System/AlternateDataStreams/AlternateDataStreams-$comp_name.csv" ]; then
    cat $case_dir/File_System/AlternateDataStreams/AlternateDataStreams-$comp_name.csv >> $timeline_dir/Triage-Timeline-$comp_name.csv
  fi
  if [ -f "$timeline_dir/Triage-Timeline-$comp_name.csv" ]; then
    tln_csv="$timeline_dir/Triage-Timeline-$comp_name.csv"
    tln_template="/usr/local/src/dfir-scripts/csv2XLsheet/templates/TLNSlicer.xltx"
    tln_sheet="TLN-Slicer"
    tln_output="$case_dir/All_Slicers/Triage-Timeline-$comp_name.xlsx"
    if [ $(wc -l <$timeline_dir/Triage-Timeline-$comp_name.csv) -ge 2 ]; then
      $csv2XL -i $tln_csv -t $tln_template -s $tln_sheet -r 2 -o $tln_output
    else
      rm $timeline_dir/Triage-Timeline-$comp_name.csv 2> /dev/null
    fi
  fi
}

function scan_for_lolbas(){
  #***** Lolbas in EVTX *****************************
  if  [ "$(ls -A $case_dir/WindowsEventLogs/evtx_dump_$comp_name/ 2>/dev/null)" ]; then
    make_green "Searching for executables identified as lolbas"
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p  "$case_dir/WindowsEventLogs/evtx_dump_$comp_name/" -l /opt/app/keywords/lolbas.csv >> $case_dir/Application_Execution/lolbas/lolbas-in-evtx-$comp_name.csv
    if [  -f "$case_dir/Application_Execution/lolbas/lolbas-in-evtx-$comp_name.csv" ] ; then
      sed -i "1i lolbas_file,source,message" $case_dir/Application_Execution/lolbas/lolbas-in-evtx-$comp_name.csv
    fi
  fi

  #***** Lolbas in prefetch ***************************
  if  [ "$(ls -A $case_dir/Application_Execution/Prefetch/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Application_Execution/Prefetch/ -l /opt/app/keywords/lolbas.csv >> $case_dir/Application_Execution/lolbas/lolbas-in-Prefetch-$comp_name.csv
    if  [ -f "$case_dir/Application_Execution/lolbas/lolbas-in-Prefetch-$comp_name.csv" ] ; then
      sed -i "1i lolbas_file,source,message" $case_dir/Application_Execution/lolbas/lolbas-in-Prefetch-$comp_name.csv
    fi
  fi

    #***** Lolbas in AmCache ***************************
  if  [ "$(ls -A $case_dir/Application_Execution/Amcache/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Application_Execution/Amcache/ -l /opt/app/keywords/lolbas.csv >> $case_dir/Application_Execution/lolbas/lolbas-in-AmCache-$comp_name.csv
    if  [ -f "$case_dir/Application_Execution/lolbas/lolbas-in-AmCache-$comp_name.csv" ] ; then
      sed -i "1i lolbas_file,source,message" $case_dir/Application_Execution/lolbas/lolbas-in-AmCache-$comp_name.csv
    fi
  fi

  #***** Lolbas in Services ***************************
  if  [ "$(ls -A $case_dir/Persistence/ 2>/dev/null)" ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Persistence/ -l /opt/app/keywords/lolbas.csv >> $case_dir/Application_Execution/lolbas/lolbas-in-Persistence-$comp_name.csv
    if  [ -f "$case_dir/Application_Execution/lolbas/lolbas-in-Services-$comp_name.csv" ] ; then
      sed -i "1i lolbas_file,source,message" $case_dir/Application_Execution/lolbas/lolbas-in-Services-$comp_name.csv
    fi
  fi

  #***** Lolbas in Bits *****************************
  if  [ $( -f "$case_dir/Persistence/BITS/parse_evtx_BITS.py-$comp_name.csv" 2>/dev/null) ] ; then
    /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p \
    $case_dir/Persistence/BITS/ -l /opt/app/keywords/lolbas.csv >> $case_dir/Application_Execution/lolbas/lolbas-in-BITS-$comp_name.csv
    if  [ -f "$case_dir/Application_Execution/lolbas/lolbas-in-BITS-$comp_name.csv" ] ; then
      sed -i "1i lolbas_file,source,message" $case_dir/Application_Execution/lolbas/lolbas-in-BITS-$comp_name.csv
    fi
  fi

  #***** Lolbas in Windows Timeline *****************************
  find $case_dir/Timeline/WinActivitiesCache/ -type f 2>/dev/null |grep WindowsTimeline.sql | \
    while read f;
    do
      user_name=$(echo "$f"|sed 's|.*/||' |awk -F'\\-' '{print $2}')
      cat "$f" 2>/dev/null| awk -F'|' '{print $3}'|grep  exe|awk -F'\' '{print $NF}' >> /tmp/exe.txt
      [ -f "/tmp/exe.txt" ] &&  /opt/venv/bin/python /opt/app/dfir-scripts/WinEventLogs/scanforlolbas.py -p  /tmp/exe.txt -l /opt/app/keywords/lolbas.csv | \
      awk -F',' '{print $1}' |sed 's/ /,/' |sort | uniq -c | sort -rn >> $case_dir/Application_Execution/lolbas/lolbas-in-ActivitiesCache-$comp_name.csv
      [ -f $case_dir/Application_Execution/lolbas/lolbas-in-ActivitiesCache-$comp_name.csv ] && sed -i "s/$/,$user_name/" $case_dir/Application_Execution/lolbas/lolbas-in-ActivitiesCache-$comp_name.csv && \
      sed -i "1i Count lolbas_file,User_Name" $case_dir/Application_Execution/lolbas/lolbas-in-ActivitiesCache-$comp_name.csv
      rm /tmp/exe.txt 2>/dev/null
    done
  #***** Lolbas in WinActivitiesCache *****************************
    [ -f $case_dir/All_Summary/WinActivitiesCache-stats-$comp_name.csv ] && sed -i "s/$/,$user_name/" $case_dir/All_Summary/WinActivitiesCache-stats-$comp_name.csv && \
    sed -i "1i Count lolbas_file,User_Name" $case_dir/All_Summary/WinActivitiesCache-stats-$comp_name.csv
}

###########Zimmeman Artifact Parsers ##################################
#amcacheparser
function z_amcacheparser(){
dotnet /opt/zimmermantools/net9/AmcacheParser.dll --csvf amcacheparser_$comp_name.csv -f "$amcache_hive" --csv $case_dir/Application_Execution/Amcache 
}
#appcompatparser
function z_appcompatcacheparser(){
cd $regdir
dotnet /opt/zimmermantools/net9/AppCompatCacheParser.dll --csvf AppCompat_$comp_name.csv -f $system_hive --csv $case_dir/Application_Execution/Shimcache
}

#Zimmerman lnk and Jumplist Parser
function z_lecmd_jlecmd(){
    cd $mount_dir
    fd -i -d 2 -t f "ntuser.dat$" "$user_dir"| \
    while read ntuser_path;
    do
      user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
      find $user_dir/$user_name -maxdepth 0 -type d |while read d;
      do
        dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_$user_name-Recent-$comp_name.csv -d "$d/AppData/Roaming/Microsoft" --$out_format $case_dir/File_Access/LNK/$user_name-$comp_name
        dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_$user_name-Desktop-$comp_name.csv -d "$d/Desktop" --$out_format $case_dir/File_Access/LNK/$user_name-$comp_name
        dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_$user_name-Downloads-$comp_name.csv -d "$d/Downloads" --$out_format $case_dir/File_Access/LNK/$user_name-$comp_name
        dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_$user_name-Documents-$comp_name.csv -d "$d/Documents" --$out_format $case_dir/File_Access/LNK/$user_name-$comp_name
        dotnet /opt/zimmermantools/net9/JLECmd.dll --csvf JLECmd_$user_name-$comp_name.csv -d "$d/AppData/Roaming/Microsoft/Windows/Recent" --$out_format $case_dir/Application_Execution/Jumplist/$user_name-$comp_name
      done
    done
  find $all_users/Microsoft/Windows/ -maxdepth 0 -type d |while read d;
  do
    dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_AllUsers-$comp_name.csv -d "$d" --$out_format $case_dir/File_Access/LNK/AllUsers-$comp_name
    dotnet /opt/zimmermantools/net9/JLECmd.dll --csvf JLECmd_AllUsers-$comp_name.csv -d "$d" --$out_format $case_dir/Application_Execution/Jumplist/AllUsers-$comp_name
  done
  dotnet /opt/zimmermantools/net9/LECmd.dll --csvf LECmd_Public.csv -d "$user_dir/Public" --$out_format $case_dir/File_Access/LNK/Public-$comp_name
}
#mftparser
function z_mftecmd(){
  if [ -f "$mount_dir/\$MFT" ]; then
    cd $mount_dir
    [ -f "\$MFT" ] && \
    dotnet /opt/zimmermantools/net9/MFTECmd.dll --csvf MFTECmd_$comp_name.csv -f \$MFT --$out_format $case_dir/File_System/MFT
  fi
  #Copy ADS and Unallocated files
  if [ -f "$case_dir/File_System/MFT/MFTECmd_$comp_name.csv" ]; then
    head -n1 $case_dir/File_System/MFT/MFTECmd_$comp_name.csv | tee $case_dir/File_System/AlternateDataStreams/AlternateDataStreams-$comp_name.csv && \
    cat $case_dir/File_System/MFT/MFTECmd_$comp_name.csv | awk -F, '$14 ~ /^(True)$/{print $0}'|tee -a $case_dir/File_System/AlternateDataStreams/MFTECmd-AlternateDataStreams-$comp_name.csv
    cat $case_dir/File_System/AlternateDataStreams/MFTECmd-AlternateDataStreams-$comp_name.csv | grep -v "Created0x10.ADS" | \
    awk -F"," '{print $20",ADS,comp_name,,FILE Created: "$6"\\"$7}' |sed "s/comp_name/$comp_name/" >> $case_dir/File_System/AlternateDataStreams/AlternateDataStreams-$comp_name.csv
    cat $case_dir/File_System/MFT/MFTECmd_$comp_name.csv | awk -F, '$3 ~ /^(False)$/{print $0}'|tee -a $case_dir/File_System/Deleted_Files/MFTECmd-Unallocated-$comp_name.csv
  fi
}
#Extract $USNJRNL:$J using mftecmd
function parse_usn(){
  cd $mount_dir
  if [ -f "\$Extend/\$UsnJrnl:\$J" ]; then
    cd $mount_dir
    [ -f "\$MFT" ] && \
    dotnet /opt/zimmermantools/net9/MFTECmd.dll --csvf USNJRNL_$comp_name.csv -m \$MFT -f \$Extend/\$UsnJrnl:\$J --$out_format $case_dir/File_System/USNJRNL
  fi
}


#recyclebinparser
function z_rbcmd(){
  if [ -d "$mount_dir/\$Recycle.Bin" ]; then
    cd $mount_dir
    dotnet /opt/zimmermantools/net9/RBCmd.dll --csvf RBCmd_$comp_name.csv -d '$Recycle.Bin/' --csv $case_dir/File_System/Deleted_Files 2>/dev/null
  fi
}
#recentfilecacheparser
function z_recentfilecacheparser(){
recent_file_cache="$windir/AppCompat/Programs/RecentFileCache.bcf" 
dotnet /opt/zimmermantools/net9/RecentFileCacheParser.dll --csvf RFCmd_$comp_name.csv -f "$recent_file_cache" --$out_format $case_dir/RecentFileCache
}
#rla merged dirty registry hives
function z_rla(){
  cd "$user_dir"
  fd -i -d 2 -t f "ntuser.dat$" "$user_dir" 2>/dev/null | \
  while read ntuser_path;
  do
    user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
    dotnet /opt/zimmermantools/net9/rla.dll --nop --ca false -f "$ntuser_path" --out $case_dir/Registry_Files/$comp_name-$user_name 2>/dev/null
  done
  cd "$regdir"
  dotnet /opt/zimmermantools/net9/rla.dll --nop --ca false -d "$regdir" --out $case_dir/Registry_Files/$comp_name-config 2>/dev/mull
}

#sbecmd  shellbags
function z_sbecmd(){
  fd -i -d 2 -t f "ntuser.dat$" "$user_dir" 2>/dev/null |\
  while read ntuser_path;
  do
    user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
    fd -d 1 -i -t d windows$ $user_dir/$user_name/AppData/Local/Microsoft/ | \
    while read d; 
    do
      dotnet /opt/zimmermantools/net9/SBECmd.dll --csvf SBECmd_$user_name-$comp_name.csv -d "$d" --$out_format $case_dir/File_Access/ShellBags/SBECmd-$user_name-$comp_name
    done
  done
 }
#Winactivities
function z_wxtcmd(){
  cd /opt/zimmermantools/WxTCmd/
  fd -i -d 2 -t f "ntuser.dat$" "$user_dir"|\
  while read ntuser_path;
  do
    user_name=$( echo "$ntuser_path"|sed 's/\/$//'|awk -F"/" '{print $(NF-1)}')
    find -P $user_dir/*/AppData/Local/ConnectedDevicesPlatform/*/ 2>/dev/null |grep -i ActivitiesCache.db$ | \
    while read d;
    do
      /opt/zimmermantools/WxTCmd/WxTCmd -f $d --csv $case_dir/Timeline/WinActivitiesCache/$user_name
    done
  done
  cd $mount_dir
}

#RECmd
#function z_recmd(){
#dotnet /opt/zimmermantools/net9/RECmd/RECmd.dll -d $regdir --bn /opt/zimmermantools/net9/RECmd/BatchExamples/BasicSystemInfo.reb --$out_format $case_dir/Zimmerman/RECmd
#dotnet /opt/zimmermantools/net9/RECmd/RECmd.dll -d $user_dir --bn /opt/zimmermantools/net9/RECmd/BatchExamples/BasicSystemInfo.reb --$out_format $case_dir/Zimmerman/RECmd
#}

#EvtXCmd
function z_evtxecmd(){
dotnet /opt/zimmermantools/net9/EvtxeCmd/EvtxECmd.dll --jsonf EvtxECmd_$comp_name.json -d $evtxdir --$out_format $case_dir/WindowsEventLogs/Zimmerman
}

clear
[ $(whoami) != "root" ] && make_red "dfir-scripts Requires Root!" && exit
show_menu
exit 0